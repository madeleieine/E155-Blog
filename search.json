[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "HMC E155 Website\nHMC E85 Website"
  },
  {
    "objectID": "resources.html#course-websites",
    "href": "resources.html#course-websites",
    "title": "E155 Portfolio",
    "section": "",
    "text": "HMC E155 Website\nHMC E85 Website"
  },
  {
    "objectID": "posts/lab1-reflection.html",
    "href": "posts/lab1-reflection.html",
    "title": "Lab 1 Reflection",
    "section": "",
    "text": "2-3 para reflection\nThis blog was an eye-opening experience for sure. While my friends from the class warned me that it might take a while, I didn‚Äôt really internalize what they said. I ended up mismanaging my time, pushing off a lot of the work to the last minute, and ultimately not completing the testvectors. Moving forward, I will do my best to schedule 20 hours for each lab in the days leading up to the check-off date so I don‚Äôt have to scramble in the same way. I definitely focus better when I‚Äôm well-rested, and I think getting into a good work routine will be helpful (especially when the swim season starts).\nI do think I enjoyed the lab. It felt like a review of the engineering skills I have learned so far, both in E85 with SystemVerilog programming, and from E80 and Clinic with soldering (and de-soldering). It was nice to get to review a variety of these skills all in one lab, and I feel prepared to take on lab 2.\nI didn‚Äôt get to the test benches on my first try at the lab (due to aforementioned time management issues), but I am working on that now for the regrade. Between taking E85 a year ago and MicroPs now, I worked a bit on developing a testbench for an astronomical random number generator in the physics lab I research with. It was different from E85 since it used Verilog and a different IDE, but it was exciting to see a real-world application of E85 skills. Another exciting thing in lecture was when prof. Spencer gave an example of a synchronous design challenge, and it was very similar to the project I was working on two summers ago in that same lab! Overall, I am really excited about the applications of computer engineering, and I can‚Äôt wait to develop my sills."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Hello Quarto",
    "section": "",
    "text": "I am so excited to be blogging today! :D"
  },
  {
    "objectID": "labs/labs-overview.html",
    "href": "labs/labs-overview.html",
    "title": "Labs Overview",
    "section": "",
    "text": "Below is an outline of the Labs I have worked on for Microprocessor-Based Systems: Design and Applications. Labs 1-3 focus on FPGA programming (in both simulation and hardware), labs 4-6 focus on MCU programming, and lab 7 involves communication between the MCU and the FPGA (with the FPGA acting as an accelerator for encryption)."
  },
  {
    "objectID": "labs/labs-overview.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/labs-overview.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "Labs Overview",
    "section": "Lab 1: FPGA and MCU Setup and Testing",
    "text": "Lab 1: FPGA and MCU Setup and Testing"
  },
  {
    "objectID": "labs/labs-overview.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/labs-overview.html#lab-2-multiplexed-7-segment-display",
    "title": "Labs Overview",
    "section": "Lab 2: Multiplexed 7-segment Display",
    "text": "Lab 2: Multiplexed 7-segment Display"
  },
  {
    "objectID": "labs/labs-overview.html#lab-3-keypad-scanner",
    "href": "labs/labs-overview.html#lab-3-keypad-scanner",
    "title": "Labs Overview",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs/labs-overview.html#lab-4-digital-audio",
    "href": "labs/labs-overview.html#lab-4-digital-audio",
    "title": "Labs Overview",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs/labs-overview.html#lab-5-interrupts",
    "href": "labs/labs-overview.html#lab-5-interrupts",
    "title": "Labs Overview",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs/labs-overview.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs/labs-overview.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Labs Overview",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs/labs-overview.html#lab-7-the-advanced-encryption-standard",
    "href": "labs/labs-overview.html#lab-7-the-advanced-encryption-standard",
    "title": "Labs Overview",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6",
    "section": "",
    "text": "The goal of Lab 6 was to read a temperature using the SPI (serial peripheral interface) communication protocol. The resolution of this reading (as well as an on-board) LED were controlled with a web server using HTTP (hypertext transfer protocol), and the temperature is also displayed on the web server."
  },
  {
    "objectID": "labs/lab6/lab6.html#introduction",
    "href": "labs/lab6/lab6.html#introduction",
    "title": "Lab 6",
    "section": "",
    "text": "The goal of Lab 6 was to read a temperature using the SPI (serial peripheral interface) communication protocol. The resolution of this reading (as well as an on-board) LED were controlled with a web server using HTTP (hypertext transfer protocol), and the temperature is also displayed on the web server."
  },
  {
    "objectID": "labs/lab6/lab6.html#schematic",
    "href": "labs/lab6/lab6.html#schematic",
    "title": "Lab 6",
    "section": "Schematic",
    "text": "Schematic\nThe circuit diagram is as follows:"
  },
  {
    "objectID": "labs/lab6/lab6.html#code",
    "href": "labs/lab6/lab6.html#code",
    "title": "Lab 6",
    "section": "Code:",
    "text": "Code:\n/**\n    Main Header: Contains general defines and selected portions of CMSIS files\n    @file main.h\n    @author Madeleine Kan, adapted from Josh Brake\n    @version 10/27/25\n*/\n\n#ifndef MAIN_H\n#define MAIN_H\n\n#include \"STM32L432KC.h\"\n\n#define LED_PIN PA6 // LED pin for blinking on Port A pin 9\n#define BUFF_LEN 32\n\nchar* webpageStart = \"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Madeleine Kan E155 Web Server Webpage&lt;/title&gt;\\\n    &lt;meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"&gt;\\\n    &lt;/head&gt;\\\n    &lt;body&gt;&lt;h1&gt;E155 Web Server Demo Webpage&lt;/h1&gt;\";\nchar* ledStr = \"&lt;p&gt;LED Control:&lt;/p&gt;&lt;form action=\\\"ledon\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"Turn the LED on!\\\"&gt;&lt;/form&gt;\\\n    &lt;form action=\\\"ledoff\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"Turn the LED off!\\\"&gt;&lt;/form&gt;\";\nchar* resolutionStr = \"&lt;p&gt;Resolution Control:&lt;/p&gt;&lt;form action=\\\"8\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"8 bits\\\"&gt;&lt;/form&gt;\\\n      &lt;form action=\\\"9\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"9 bits\\\"&gt;&lt;/form&gt;\\\n      &lt;form action=\\\"10\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"10 bits\\\"&gt;&lt;/form&gt;\\\n      &lt;form action=\\\"11\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"11 bits\\\"&gt;&lt;/form&gt;\\\n      &lt;form action=\\\"12\\\"&gt;&lt;input type=\\\"submit\\\" value=\\\"12 bits\\\"&gt;&lt;/form&gt;\";\nchar* webpageEnd   = \"&lt;/body&gt;&lt;/html&gt;\";\n\n#endif // MAIN_H\n/*\nFile: lab6_mk.c\nAuthor: Madeleine Kan, adopted from Josh Brake\nEmail: mkane@hmc.edu\nDate: 10/27/25\n*/\n\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include \"main.h\"\n#include \"ds1722.h\"\n\n\n/////////////////////////////////////////////////////////////////\n// Provided Constants and Functions\n/////////////////////////////////////////////////////////////////\n\n\n//determines whether a given character sequence is in a char array request, returning 1 if present, -1 if not present\nint inString(char request[], char des[]) {\n    if (strstr(request, des) != NULL) {return 1;}\n    return -1;\n}\n\nint updateLEDStatus(char request[])\n{\n    int led_status = 0;\n    // The request has been received. now process to determine whether to turn the LED on or off\n    if (inString(request, \"ledoff\")==1) {\n        digitalWrite(LED_PIN, PIO_LOW);\n                printf(\"off \\n\");\n        led_status = 0;\n    }\n    else if (inString(request, \"ledon\")==1) {\n        digitalWrite(LED_PIN, PIO_HIGH);\n                printf(\"on \\n\");\n        led_status = 1;\n    }\n\n    return led_status;\n}\n\nint updateResolution(char request[]){\n      int resolution = 0;\n      // The request has been received. now process the resolution\n    if (inString(request, \"8\")==1) {\n                printf(\"resolution = 8 \\n\");\n        resolution = 8;\n    } else if (inString(request, \"9\")==1) {\n                printf(\"resolution = 9 \\n\");\n        resolution = 9;\n    } else if (inString(request, \"10\")==1) {\n                printf(\"resolution = 10 \\n\");\n        resolution = 10;\n    } else if (inString(request, \"11\")==1) {\n                printf(\"resolution = 11 \\n\");\n        resolution = 11;\n    } else if (inString(request, \"12\")==1) {\n                printf(\"resolution = 12 \\n\");\n        resolution = 12;\n    }\n\n    return resolution;\n\n}\n\n/////////////////////////////////////////////////////////////////\n// Solution Functions\n/////////////////////////////////////////////////////////////////\n\n\n //// internet ISO\n int main(void) {\n   configureFlash();\n   configureClock();\n\n   gpioEnable(GPIO_PORT_A);\n   gpioEnable(GPIO_PORT_B);\n   gpioEnable(GPIO_PORT_C);\n   pinMode(LED_PIN, GPIO_OUTPUT);\n   digitalWrite(LED_PIN, PIO_LOW);\n  \n   //RCC-&gt;APB2ENR |= (RCC_APB2ENR_TIM15EN);\n   //initTIM(TIM15);\n   RCC-&gt;APB1ENR1 |= (RCC_APB1ENR1_TIM2EN);\n    initTIM(TIM2);\n  \n   USART_TypeDef * USART = initUSART(USART1_ID, 125000);\n\n    // initialize SPI with (80 / 32 = ) 2.5 MHz baudrate,  cpol=0, cpha=1\n    initSPI(0b100, 0, 1);\n    volatile char config;\n    \n    // printf(\"config settings: %x \\n\", config);\n    volatile float temp;\n   while(1) {\n     /* Wait for ESP8266 to send a request.\n     Requests take the form of '/REQ:&lt;tag&gt;\\n', with TAG begin &lt;= 10 characters.\n     Therefore the request[] array must be able to contain 18 characters.\n     */\n\n     // Receive web request from the ESP\n     char request[BUFF_LEN] = \"                  \"; // initialize to known value\n     int charIndex = 0;\n  \n     // Keep going until you get end of line character\n     while(inString(request, \"\\n\") == -1) {\n       // Wait for a complete request to be transmitted before processing\n       while(!(USART-&gt;ISR & USART_ISR_RXNE));\n       request[charIndex++] = readChar(USART);\n     }\n      // Update strings with current LED state and resolution\n     int led_status = updateLEDStatus(request);\n     int resolution = updateResolution(request);\n      // configure temp sensor\n      config = configureTempSensor(resolution);\n     // SPI code here for reading temperature\n     temp = readTemp(resolution);\n     \n\n     char ledStatusStr[20];\n     char tempStatusStr[25]; // temp is double is 64 bits, or 8 bytes\n      char resolutionStatusStr[25];\n     sprintf(tempStatusStr, \"temp: %.4f deg C\\n\", temp);\n     sprintf(resolutionStatusStr, \"resolution = %d bits\", resolution);\n     //printf(\"%f\", temp);\n     //printf(tempStatusStr);\n\n     if (led_status == 1){\n       sprintf(ledStatusStr,\"LED is on!\");\n     } else if (led_status == 0){\n       sprintf(ledStatusStr,\"LED is off!\");\n    }\n\n     // finally, transmit the webpage over UART\n     sendString(USART, webpageStart); // webpage header code\n     sendString(USART, ledStr); // button for controlling LED\n     sendString(USART, resolutionStr); // buttons for controlling resolution\n\n     sendString(USART, \"&lt;h2&gt;LED Status&lt;/h2&gt;\");\n\n     sendString(USART, \"&lt;p&gt;\");\n     sendString(USART, ledStatusStr);\n     sendString(USART, \"&lt;/p&gt;\");\n\n     sendString(USART, \"&lt;h2&gt;Temperature&lt;/h2&gt;\");\n\n     sendString(USART, \"&lt;p&gt;\");\n     sendString(USART, tempStatusStr);\n     sendString(USART, \"&lt;/p&gt;\");\n     sendString(USART, \"&lt;p&gt;\");\n     sendString(USART, resolutionStatusStr);\n     sendString(USART, \"&lt;/p&gt;\");\n\n\n  \n     sendString(USART, webpageEnd);\n   }\n }\n// DS1722.h\n// Madeleine Kan\n// mkan@hmc.edu\n// 27 October 2025\n// Header file for DS1722 temperature sensor\n\n#ifndef DS1722_H\n#define DS1722_H\n#include \"STM32L432KC.h\"\nvolatile char configureTempSensor(int resolution);\nvolatile float readTemp(int resolution);\n#endif\n// DS1722.c\n// Madeleine Kan\n// mkan@hmc.edu\n// 27 October 2025\n// Functionality for DS1722 temperature sensor\n\n#include \"STM32L432KC.h\"\n// configures and enables temperature sensor for 8-12 bits of resolution\n// then, reads back configuration\n// returns int corresponding to configuration settingss\nvolatile char configureTempSensor(int resolution){\n  // first 4 bits of config status register will always be 1110 since we don't want one shot mode\n  // last 4 bits will be 3'bresolution_SD\n  // since we are enabling the temp sensor, we are writing 0 to SD\n  volatile char result1;\n  volatile char result2;\n  volatile char config;\n  int a = 0;\n  digitalWrite(CS, PIO_HIGH);\n   // config write address\n  spiSendReceive(0x80);\n\n  switch(resolution){\n    case 8: \n      result2 = spiSendReceive(0xE0);\n      break;\n    case 9: \n      result2 = spiSendReceive(0xE2);\n      break;\n    case 10: \n      result2 = spiSendReceive(0xE4);\n      break;\n    case 11: \n      result2 = spiSendReceive(0xE6);\n      break;\n    case 12: \n      result2 = spiSendReceive(0xE8);\n      break;\n    default:\n    break;\n  }\n  digitalWrite(CS, PIO_LOW);\n\n  digitalWrite(CS,  PIO_HIGH);\n  spiSendReceive(0x0);\n  config = spiSendReceive(0x00);\n  digitalWrite(CS,  PIO_LOW);\n  \n  printf(\"old settings: %x \\n\", result1);\n  printf(\"other settings: %x \\n\", result2);\n  printf(\"new settings: %x \\n\", config);\n  \n  return config;\n}\n\nvolatile float readTemp(int resolution){\n  volatile int16_t temp_MSB = 0;\n  volatile int16_t temp_LSB = 0;\n  volatile float frac_temp_LSB = 0;\n  volatile float temp_raw = 0;\n  volatile float temp = 0;\n\n\n  int isPositive = 0;\n  digitalWrite(CS, PIO_HIGH);\n  spiSendReceive(0x02);\n  temp_MSB = (uint16_t) spiSendReceive(0x00);\n  spiSendReceive(0x00);\n  digitalWrite(CS, PIO_LOW);\n\n  digitalWrite(CS, PIO_HIGH);\n  spiSendReceive(0x01);\n  temp_LSB = (uint16_t) spiSendReceive(0x00);\n  spiSendReceive(0x00);\n  digitalWrite(CS, PIO_LOW);\n  \n  temp_raw = ((temp_MSB &lt;&lt; 8) | temp_LSB);\n  temp = temp_raw/256;\n  printf(\"temp LSB: %x \\n\", temp_LSB);\n  printf(\"temp MSB: %x \\n\", temp_MSB);\n  printf(\"temp: % .4f\\n\", temp);\n  return temp;\n}\nAnd the SPI code, from the interrupt-tutorial solution branch:\n// STM32L432KC_SPI.h\n// Header for SPI functions\n\n#ifndef STM32L4_SPI_H\n#define STM32L4_SPI_H\n\n#include &lt;stdint.h&gt;\n#include &lt;stm32l432xx.h&gt;\n\n#define SCK PB3\n#define CIPO PB4\n#define COPI PB5\n#define CS PB1\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\n/* Enables the SPI peripheral and intializes its clock speed (baud rate), polarity, and phase.\n *    -- br: (0b000 - 0b111). The SPI clk will be the master clock / 2^(BR+1).\n *    -- cpol: clock polarity (0: inactive state is logical 0, 1: inactive state is logical 1).\n *    -- cpha: clock phase (0: data captured on leading edge of clk and changed on next edge, \n *          1: data changed on leading edge of clk and captured on next edge)\n * Refer to the datasheet for more low-level details. */ \nvoid initSPI(int br, int cpol, int cpha);\n\n/* Transmits a character (1 byte) over SPI and returns the received character.\n *    -- send: the character to send over SPI\n *    -- return: the character received over SPI */\nchar spiSendReceive(char send);\n\n#endif\n// STM32L432KC_SPI.c\n// Source code for SPI functions\n\n#include \"STM32L432KC.h\"\n#include \"STM32L432KC_SPI.h\"\n#include \"STM32L432KC_GPIO.h\"\n#include \"STM32L432KC_RCC.h\"\n\n/* Enables the SPI peripheral and intializes its clock speed (baud rate), polarity, and phase.\n *    -- br: (0b000 - 0b111). The SPI clk will be the master clock / 2^(BR+1).\n *    -- cpol: clock polarity (0: inactive state is logical 0, 1: inactive state is logical 1).\n *    -- cpha: clock phase (0: data captured on leading edge of clk and changed on next edge, \n *          1: data changed on leading edge of clk and captured on next edge)\n * Refer to the datasheet for more low-level details. */ \nvoid initSPI(int br, int cpol, int cpha) {\n    // Turn on GPIOA and GPIOB clock domains (GPIOAEN and GPIOBEN bits in AHB1ENR)\n    RCC-&gt;AHB2ENR |= (RCC_AHB2ENR_GPIOAEN | RCC_AHB2ENR_GPIOBEN);\n    \n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SPI1EN; // Turn on SPI1 clock domain (SPI1EN bit in APB2ENR)\n\n    // Initially assigning SPI pins\n    pinMode(SCK, GPIO_ALT); // SPI1_SCK\n    pinMode(CIPO, GPIO_ALT); // SPI1_MISO\n    pinMode(COPI, GPIO_ALT); // SPI1_MOSI\n    pinMode(CS, GPIO_OUTPUT); //  Manual CS\n\n    // Set output speed type to high for SCK\n    GPIOB-&gt;OSPEEDR |= (GPIO_OSPEEDR_OSPEED3);\n\n    // Set to AF05 for SPI alternate functions\n    GPIOB-&gt;AFR[0] |= _VAL2FLD(GPIO_AFRL_AFSEL3, 5);\n    GPIOB-&gt;AFR[0] |= _VAL2FLD(GPIO_AFRL_AFSEL4, 5);\n    GPIOB-&gt;AFR[0] |= _VAL2FLD(GPIO_AFRL_AFSEL5, 5);\n    \n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_BR, br); // Set baud rate divider\n\n    SPI1-&gt;CR1 |= (SPI_CR1_MSTR);\n    SPI1-&gt;CR1 &= ~(SPI_CR1_CPOL | SPI_CR1_CPHA | SPI_CR1_LSBFIRST | SPI_CR1_SSM);\n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_CPHA, cpha);\n    SPI1-&gt;CR1 |= _VAL2FLD(SPI_CR1_CPOL, cpol);\n    SPI1-&gt;CR2 |= _VAL2FLD(SPI_CR2_DS, 0b0111);\n    SPI1-&gt;CR2 |= (SPI_CR2_FRXTH | SPI_CR2_SSOE);\n\n    SPI1-&gt;CR1 |= (SPI_CR1_SPE); // Enable SPI\n}\n\n/* Transmits a character (1 byte) over SPI and returns the received character.\n *    -- send: the character to send over SPI\n *    -- return: the character received over SPI */\nchar spiSendReceive(char send) {\n    while(!(SPI1-&gt;SR & SPI_SR_TXE)); // Wait until the transmit buffer is empty\n    *(volatile char *) (&SPI1-&gt;DR) = send; // Transmit the character over SPI\n    while(!(SPI1-&gt;SR & SPI_SR_RXNE)); // Wait until data has been received\n    char rec = (volatile char) SPI1-&gt;DR;\n    return rec; // Return received character\n}"
  },
  {
    "objectID": "labs/lab6/lab6.html#results",
    "href": "labs/lab6/lab6.html#results",
    "title": "Lab 6",
    "section": "Results",
    "text": "Results\nThe lab worked as expected! The webserver succesfully turns the on board LED on and off, and the temperature (at the specified resoltuion) is displayed on the website.\nBelow is an oscilloscope trace showing the SPI transaction where the temperature sensor is configured to read temperature with 9 bits of resoltuion:\n\nAnd below is a trace of an SPI transaction where temperature data is being read from the temperature sensor. The address 0x02 pulls the upper bits of the temperature data (0x17), and the address 0x01 pulls the lower bits of the temperature data (0x10)"
  },
  {
    "objectID": "labs/lab6/lab6.html#summary",
    "href": "labs/lab6/lab6.html#summary",
    "title": "Lab 6",
    "section": "Summary",
    "text": "Summary\nI have spent around 20 hours on this lab. I learned a lot about the SPI protocol, using logic analyzers, and HTTP."
  },
  {
    "objectID": "labs/lab6/lab6.html#ai-reflection",
    "href": "labs/lab6/lab6.html#ai-reflection",
    "title": "Lab 6",
    "section": "AI Reflection",
    "text": "AI Reflection\n\nWebpage is pretty good! Doesn‚Äôt look amazing but it does have the functionality I was looking for. It used Javascript for its fake temperature calculation, so I had to comment that out. This would be a helpful place to start when building a website from scratch, although I would definitely modify it.\nOriginally used HAL library rather than cmsis, which we do not have access to for this class unfortunately but it was still a reasonable assumption because that is what we did for clinic. I reprompted chatgpt and it gave me new code that uses the CMSIS library and interfaces with registers directly. ChatGPT gave a some useful Hardware & Configuration notes, which I used to adapt the code for my pin assignments. However, the use of the CMSIS library was not super thorough, and things like GPIO bank addresses were hardcoded as registers which made it difficult to adjust the pin assignments. Additionally, the code configured all 3 pins into high speed mode, which seemed perhaps unecessary. The code was certainly useful to look at, but it was a few steps away from what I think would have been ideal."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4",
    "section": "",
    "text": "The purpose of Lab 4 was to program an STM32 MCU to play a sequence of specified frequencies and durations. Currently, it is capable of playing excerpts from Fur Elise by Beethoven and Hopes and Dreams by Toby Fox."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab 4",
    "section": "",
    "text": "The purpose of Lab 4 was to program an STM32 MCU to play a sequence of specified frequencies and durations. Currently, it is capable of playing excerpts from Fur Elise by Beethoven and Hopes and Dreams by Toby Fox."
  },
  {
    "objectID": "labs/lab4/lab4.html#schematic",
    "href": "labs/lab4/lab4.html#schematic",
    "title": "Lab 4",
    "section": "Schematic",
    "text": "Schematic\nThe circuit diagram is as follows:"
  },
  {
    "objectID": "labs/lab4/lab4.html#calculations",
    "href": "labs/lab4/lab4.html#calculations",
    "title": "Lab 4",
    "section": "Calculations",
    "text": "Calculations\nMinimum and maximum duration and frequencies:\n \nFrequency calculation for 220, 660, and 100 Hz (within 1% error):"
  },
  {
    "objectID": "labs/lab4/lab4.html#code",
    "href": "labs/lab4/lab4.html#code",
    "title": "Lab 4",
    "section": "Code:",
    "text": "Code:\nUpdated GPIO.h library header file:\n// STM32L432KC_GPIO.h\n// Header for GPIO functions\n// Madeleine Kan\n// mkan@hmc.edu\n// 10/6/25\n#ifndef STM32L4_GPIO_H\n#define STM32L4_GPIO_H\n\n#include &lt;stdint.h&gt; // Include stdint header\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n// Values for GPIO pins (\"val\" arguments)\n#define GPIO_LOW    0\n#define GPIO_HIGH   1\n\n// Base addresses for GPIO ports\n#define GPIOB_BASE  (0x48000400UL)\n#define GPIOA_BASE  (0x48000000UL)\n// see button interrupt tutorial, pin A + more generality\n\n// Arbitrary GPIO functions for pinMode()\n#define GPIO_INPUT  0\n#define GPIO_OUTPUT 1\n#define GPIO_ALT    2\n#define GPIO_ANALOG 3\n\n///////////////////////////////////////////////////////////////////////////////\n// Bitfield struct for GPIO\n///////////////////////////////////////////////////////////////////////////////\n\n// GPIO register structs here\ntypedef struct {\n    volatile uint32_t MODER;   // GPIO Offset 0x00 GPIO port mode register\n    volatile uint32_t OTYPER;  // GPIO Offset 0x04\n    volatile uint32_t OSPEEDR; // GPIO Offset 0x08\n    volatile uint32_t PURPDR;  // GPIO Offset 0x0C\n    volatile uint32_t IDR;     // GPIO Offset 0x10\n    volatile uint32_t ODR;     // GPIO Offset 0x14\n    volatile uint32_t BSRR;    // GPIO Offset 0x18\n    volatile uint32_t LCKR;    // GPIO Offset 0x1C\n    volatile uint32_t AFRL;    // GPIO Offset 0x20\n    volatile uint32_t AFRH;    // GPIO Offset 0x24\n} GPIO;\n\n// Pointers to GPIO-sized chunks of memory for each peripheral\n#define GPIOB ((GPIO *) GPIOB_BASE)\n\n#define GPIOA ((GPIO *) GPIOA_BASE)\n\n#define GPIO GPIOA\n\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid pinMode(int pin, int function);\n\nint digitalRead(int pin);\n\nvoid digitalWrite(int pin, int val);\n\nvoid togglePin(int pin);\n\n\n#endif\nUpdated RCC.c library file:\n// STM32L432KC_RCC.c\n// Source code for RCC functions\n// Madeleine Kan\n// mkan@hmc.edu\n// 10/6/25\n\n#include \"STM32L432KC_RCC.h\"\n\nvoid configureClock(){\n    // MSI is automatically set as systemclock\n    RCC-&gt;APB2ENR |= (1 &lt;&lt; 17); // tim16 timer clk enable\n    RCC-&gt;APB2ENR |= (1 &lt;&lt; 16); // tim15 timer clk enable\n\n}\nNew TIMER.c library file:\n// TIMER.c\n// Source code for Timer functions (delay and output 50% PWM at desired frequency)\n// Madeleine Kan\n// mkan@hmc.edu\n// 10/6/25\n\n#include \"STM32L432KC_TIMER.h\"\n\nvoid configureTimer(TIM_TypeDef* TIMx, int PWM) {\n  if (PWM == 1) {\n    TIMx-&gt;CCMR1 |= (0b110 &lt;&lt; 4);    // set PWM mode 1 (active high)\n    TIMx-&gt;CCMR1 |= (1 &lt;&lt; 3);    // output compare 1 preload enable\n    TIMx-&gt;BDTR |= (1 &lt;&lt; 15);    // main output enable\n    // TIMx-&gt;CCER |= (1 &lt;&lt; 1); // CC1E, enable OC1 signal \n    TIMx-&gt;CCER |= (1 &lt;&lt; 0); // CC1E, enable OC1 signal \n  }\n  // preload value copied into active capture/compare register when update event occurs\n  // update generation... cleared by hardware, care of enable and disabling counter\n  TIMx-&gt;EGR |= (1 &lt;&lt; 0);    // reinitialize counter, generate update of registers\n  // enable counter\n  TIMx-&gt;CR1 |= (1 &lt;&lt; 0);    // write 1 to CEN\n  // set URS to overflow/underflow only ... maybe relevant for upcout nmode?\n  // TIMx-&gt;CR1 |= (1 &lt;&lt; 2);\n}\n\n// output PWM signal at desired frequency\nvoid setTimerFreq(TIM_TypeDef* TIMx, uint16_t freq, uint16_t prescale_val) {\n  // (4 MHz) / (prescaler_val * auto_reload_val)\n  // must span 220-1000 Hz with 1% accuracy\n  //uint16_t prescale_val;\n  \n  uint16_t auto_reload_val;\n  if (freq &gt; 0) {\n    auto_reload_val = 4000000 / freq;\n  } else {\n    auto_reload_val = 0;\n  }\n\n  uint16_t duty_cycle = auto_reload_val / 2;\n  //// clear counter\n  //TIMx-&gt;CNT &= ~(0b1111111111111111 &lt;&lt; 0);\n\n  // wite ARR\n  TIMx-&gt;ARR &= ~(0b1111111111111111 &lt;&lt; 0);    // clear ARR\n  TIMx-&gt;ARR |= (auto_reload_val &lt;&lt; 0);        // set ARR\n  // counter clock frequency (CK_CNT) = f_CKPSC / (PSC[15:0] + 1)\n  TIMx-&gt;PSC |= (prescale_val &lt;&lt; 0);    // set psc3q\n\n  // value is compared to timx_cnt, signaled on oc1 output\n  TIMx-&gt;CCR1 &= ~(0b1111111111111111 &lt;&lt; 0);    // clear CCR1\n  TIMx-&gt;CCR1 |= (duty_cycle &lt;&lt; 0);             // set PWM count\n\n  // update generation... cleared by hardware, care of enable and disabling counter\n  TIMx-&gt;EGR |= (1 &lt;&lt; 0);    // reinitialize counter, generate update of registers\n  // clear counter\n  TIMx-&gt;CNT &= ~(0b1111111111111111 &lt;&lt; 0);\n}\n\n// delay for speceified number of milliseconds\nvoid delay_millis(TIM_TypeDef* TIMx, uint16_t ms, uint16_t prescale_val) {\n  // (4 MHz) / (prescaler_val * auto_reload_val)\n  // must span 220-1000 Hz with 1% accuracy\n\n  uint16_t auto_reload_val;\n  auto_reload_val = ms;\n\n\n  // wite ARR\n  TIMx-&gt;ARR &= ~(0b1111111111111111 &lt;&lt; 0);    // clear ARR\n  TIMx-&gt;ARR |= (auto_reload_val &lt;&lt; 0);        // set ARR\n  // counter clock frequency (CK_CNT) = f_CKPSC / (PSC[15:0] + 1)\n  TIMx-&gt;PSC |= (prescale_val &lt;&lt; 0);    // set psc3q\n  // update generation... cleared by hardware, care of enable and disabling counter\n  TIMx-&gt;EGR |= (1 &lt;&lt; 0);    // reinitialize counter, generate update of registers\n  TIMx-&gt;SR &= ~(1 &gt;&gt; 0); // reset duration UIF\n  // clear counter\n  TIMx-&gt;CNT &= ~(0b1111111111111111 &lt;&lt; 0);\n\n  while ((TIMx-&gt;SR &gt;&gt; 0 & 1) != 1); // wait for UIF to be 1\n  TIMx-&gt;SR &= ~(1 &gt;&gt; 0); // reset duration UIF\n}\nNew TIMER.h library header file\n// TIMER.h\n// Header for TIMER functions\n\n#ifndef STM32L4_TIMER_H\n#define STM32L4_TIMER_H\n\n#include &lt;stdint.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n#define __IO volatile\n\n// Base addresses... programmers manual p60\n#define TIM15_BASE (0x40014000UL) // base address of TIM15 \n#define TIM16_BASE (0x40014400UL) // base address of TIM16 \n\n/**\n  * @brief Reset and Clock Control\n  */\n\ntypedef struct\n{\n  __IO uint32_t CR1;         /*!&lt; TIM control register 1,                   Address offset: 0x00 */\n  __IO uint32_t CR2;         /*!&lt; TIM control register 2,                   Address offset: 0x04 */\n  __IO uint32_t SMCR;        /*!&lt; TIM slave mode control register,          Address offset: 0x08 */\n  __IO uint32_t DIER;        /*!&lt; TIM DMA/interrupt enable register,        Address offset: 0x0C */\n  __IO uint32_t SR;          /*!&lt; TIM status register,                      Address offset: 0x10 */\n  __IO uint32_t EGR;         /*!&lt; TIM event generation register,            Address offset: 0x14 */\n  __IO uint32_t CCMR1;       /*!&lt; TIM capture/compare mode register 1,      Address offset: 0x18 */\n  __IO uint32_t CCMR2;       /*!&lt; TIM capture/compare mode register 2,      Address offset: 0x1C */\n  __IO uint32_t CCER;        /*!&lt; TIM capture/compare enable register,      Address offset: 0x20 */\n  __IO uint32_t CNT;         /*!&lt; TIM counter register,                     Address offset: 0x24 */\n  __IO uint32_t PSC;         /*!&lt; TIM prescaler,                            Address offset: 0x28 */\n  __IO uint32_t ARR;         /*!&lt; TIM auto-reload register,                 Address offset: 0x2C */\n  __IO uint32_t RCR;         /*!&lt; TIM repetition counter register,          Address offset: 0x30 */\n  __IO uint32_t CCR1;        /*!&lt; TIM capture/compare register 1,           Address offset: 0x34 */\n  __IO uint32_t CCR2;        /*!&lt; TIM capture/compare register 2,           Address offset: 0x38 */\n  __IO uint32_t CCR3;        /*!&lt; TIM capture/compare register 3,           Address offset: 0x3C */\n  __IO uint32_t CCR4;        /*!&lt; TIM capture/compare register 4,           Address offset: 0x40 */\n  __IO uint32_t BDTR;        /*!&lt; TIM break and dead-time register,         Address offset: 0x44 */\n  __IO uint32_t DCR;         /*!&lt; TIM DMA control register,                 Address offset: 0x48 */\n  __IO uint32_t DMAR;        /*!&lt; TIM DMA address for full transfer,        Address offset: 0x4C */\n  __IO uint32_t OR1;         /*!&lt; TIM option register 1,                    Address offset: 0x50 */\n  __IO uint32_t CCMR3;       /*!&lt; TIM capture/compare mode register 3,      Address offset: 0x54 */\n  __IO uint32_t CCR5;        /*!&lt; TIM capture/compare register5,            Address offset: 0x58 */\n  __IO uint32_t CCR6;        /*!&lt; TIM capture/compare register6,            Address offset: 0x5C */\n  __IO uint32_t OR2;         /*!&lt; TIM option register 2,                    Address offset: 0x60 */\n  __IO uint32_t OR3;         /*!&lt; TIM option register 3,                    Address offset: 0x64 */\n} TIM_TypeDef;\n\n#define TIM15 ((TIM_TypeDef *)TIM15_BASE)\n#define TIM16 ((TIM_TypeDef *)TIM16_BASE)\n///////////////////////////////////////////////////////////////////////////////\n// Function prototypes\n///////////////////////////////////////////////////////////////////////////////\n\nvoid configureTimer(TIM_TypeDef * TIMx, int PWM);\nvoid setTimerFreq(TIM_TypeDef * TIMx, uint16_t freq, uint16_t prescale_val);\nvoid delay_millis(TIM_TypeDef * TIMx, uint16_t ms, uint16_t prescale_val);\n\n#endif\nmain.c Source code:\n/*********************************************************************\n*                    SEGGER Microcontroller GmbH                     *\n*                        The Embedded Experts                        *\n**********************************************************************\n\n-------------------------- END-OF-HEADER -----------------------------\n\nFile    : main.c\nPurpose : Play specified song\nMadeleiene Kan\nmkan@hmc.edu\n10/6/25\n\n*/\n\n// Includes for libraries\n#include \"C:\\Users\\mkan\\Documents\\GitHub\\e155-lab4\\lib\\STM32L432KC_FLASH.h\"\n#include \"C:\\Users\\mkan\\Documents\\GitHub\\e155-lab4\\lib\\STM32L432KC_RCC.h\"\n#include \"C:\\Users\\mkan\\Documents\\GitHub\\e155-lab4\\lib\\STM32L432KC_TIMER.h\"\n#include \"C:\\Users\\mkan\\Documents\\GitHub\\e155-lab4\\lib\\STM32L432KC_GPIO.h\"\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\n// Define macros for constants\n#define LED_PIN           6\n#define DELAY_DURATION_MS    500\n\nconst int notes[][2] = {\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{416,   125},\n{494,   125},\n{523,   250},\n{  0,   125},\n{330,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{523,   125},\n{494,   125},\n{440,   250},\n{  0,   125},\n{494,   125},\n{523,   125},\n{587,   125},\n{659,   375},\n{392,   125},\n{699,   125},\n{659,   125},\n{587,   375},\n{349,   125},\n{659,   125},\n{587,   125},\n{523,   375},\n{330,   125},\n{587,   125},\n{523,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{659,   125},\n{  0,   250},\n{659,   125},\n{1319,  125},\n{  0,   250},\n{623,   125},\n{659,   125},\n{  0,   250},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{416,   125},\n{494,   125},\n{523,   250},\n{  0,   125},\n{330,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{623,   125},\n{659,   125},\n{494,   125},\n{587,   125},\n{523,   125},\n{440,   250},\n{  0,   125},\n{262,   125},\n{330,   125},\n{440,   125},\n{494,   250},\n{  0,   125},\n{330,   125},\n{523,   125},\n{494,   125},\n{440,   500},\n{  0,   0}};\n\nconst int hopes[][2] = {\n  {349, 250}, // F4\n  {  0, 125},\n  {698, 250}, // F5\n  {  0, 125},\n  {523, 500}, // C4\n  {  0, 125},\n  {466, 250}, // B4 flat\n  {  0, 125},\n  {698, 250},\n  {  0, 125},\n  {349, 500},\n  {  0, 125},\n  {349, 250},\n  {  0, 125},\n  {440, 250}, // A4\n  {  0, 125},\n  {880, 375}, // A5\n  {  0, 125},\n  {932, 125}, // B6 flat\n  {  0, 125},\n  {880, 250}, // A5\n  {  0, 125},\n  {698, 250}, // F5\n  {  0, 125},\n  {1174, 63}, // D6\n  {  0, 30},\n  {932, 63}, // B6 flat\n  {  0, 30},\n  {880, 63},\n  {  0, 30},\n  {698, 63}, //F5\n  {  0, 30},\n  {587, 63}, //D5\n  {  0, 30},\n  {523, 63}, //C5\n\n  {0, 0}\n};\n\n    int main(void) {\n    configureFlash();\n    configureClock();\n    // Turn on clock to GPIOA\n    RCC-&gt;AHB2ENR |= (1 &lt;&lt; 0);\n    pinMode(LED_PIN, GPIO_ALT);\n    GPIO-&gt;AFRL |= (0b1110 &lt;&lt; 4*LED_PIN); // set alternate function for  PA6 to AF14\n\n    // configure timers\n    uint16_t presc_freq = 0;\n    uint16_t presc_dur = 4000;\n\n    configureTimer(TIM15, 0); // upcount mode\n    configureTimer(TIM16, 1); // PWM mode\n  \n    // Play Fur Elise\n    for (int i = 0; i&lt;(sizeof(notes)/sizeof(notes[0])); i++) {\n       uint16_t freq = (uint16_t) notes[i][0];\n       uint16_t ms = (uint16_t) notes[i][1];\n       setTimerFreq(TIM16, freq, presc_freq);\n       delay_millis(TIM15, ms, presc_dur);  \n    }\n\n    // Play Hopes and Dreams\n      for (int i = 0; i&lt;(sizeof(hopes)/sizeof(hopes[0])); i++) {\n        uint16_t freq = (uint16_t) hopes[i][0];\n        uint16_t ms = (uint16_t) hopes[i][1];\n        setTimerFreq(TIM16, freq, presc_freq);\n        delay_millis(TIM15, ms, presc_dur);  \n    }\n    \n    \n    return 0;\n \n}\n\nI asked copilot. The sample code it generated was helpful, but it didn‚Äôt cover the RCC config necessary to enable the timers and the GPIO pins. Also, I ended up ising Timer 16 and 17, which it did not cover. It seems clear that the AI can be informative, but it cannot read the datasheet. Here are the results:\n\nTo generate frequencies between 220‚ÄØHz and 1‚ÄØkHz on the STM32L432KC and output them to a GPIO pin, here‚Äôs a complete breakdown of your best options and how to configure them:\n\n---\n\n### üß† Recommended Timers for Frequency Generation\n\nThe STM32L432KC features several timers, but for outputting waveforms to GPIO pins, **general-purpose timers** are ideal:\n\n| Timer | Type              | Output to GPIO | Channels | Notes |\n|-------|-------------------|----------------|----------|-------|\n| TIM2  | General-purpose   | ‚úÖ Yes          | 4        | 32-bit counter, flexible |\n| TIM5  | General-purpose   | ‚úÖ Yes          | 4        | 32-bit counter, ideal for low frequencies |\n| TIM1  | Advanced-control  | ‚úÖ Yes          | 4        | More complex, used for PWM |\n| TIM6/7| Basic timers      | ‚ùå No           | 0        | No direct GPIO output |\n| LPTIM1| Low-power timer   | ‚úÖ Yes          | 1        | Good for ultra-low-power apps |\n\nüîß **Best choice for GPIO output**: **TIM2 or TIM5**  \nThese are general-purpose timers with multiple output channels and direct GPIO mapping via alternate function (AF) settings.\n\n---\n\n### üìê Frequency Calculation Formula\n\nTo generate a specific frequency, use this formula:\n\nf_timer = SystemCoreClock / ((PSC + 1) √ó (ARR + 1))\n\nWhere:\n- `SystemCoreClock` is typically 80‚ÄØMHz on STM32L432KC\n- `PSC` = Prescaler value\n- `ARR` = Auto-reload register value\n\nYou can fix one value (usually keep `PSC` low for better resolution) and solve for the other.\n\n---\n\n### üõ†Ô∏è Key Registers to Configure\n\nTo set up a timer for frequency output:\n\n1. **Enable Timer Clock**\n   - RCC-&gt;APB1ENR |= RCC_APB1ENR_TIM2EN;\n\n2. **Configure GPIO Pin for Alternate Function**\n   - Set GPIO mode to AF\n   - Choose correct AF (e.g., AF1 for TIM2_CH1 on PA0)\n\n3. **Set Prescaler and ARR**\n   ```c\n   TIM2-&gt;PSC = prescaler_value;\n   TIM2-&gt;ARR = auto_reload_value;\n\nConfigure Output Compare Mode\nTIM2-&gt;CCMR1 |= (6 &lt;&lt; TIM_CCMR1_OC1M_Pos); // PWM mode 1\nTIM2-&gt;CCER |= TIM_CCER_CC1E;              // Enable output on CH1\nTIM2-&gt;CCR1 = ARR / 2;                     // 50% duty cycle\nEnable Timer\nTIM2-&gt;CR1 |= TIM_CR1_CEN;\n\n\n\nüîå GPIO Mapping Tips\nTo connect timer output to a GPIO pin: - Use the Alternate Function (AF) mapping in the datasheet. - Example: TIM2_CH1 is mapped to PA0 with AF1. - Configure the pin: c   GPIOA-&gt;MODER &= ~(3 &lt;&lt; (0 * 2));   GPIOA-&gt;MODER |= (2 &lt;&lt; (0 * 2)); // Alternate function   GPIOA-&gt;AFR[0] |= (1 &lt;&lt; (0 * 4)); // AF1 for TIM2_CH1\n\n\n\nüßÆ Example: Generating 440‚ÄØHz with TIM2\nAssuming SystemCoreClock = 80‚ÄØMHz:\nPSC = 181;        // Prescaler\nARR = 999;        // Auto-reload\nf = 80e6 / ((181+1)*(999+1)) = ~440 Hz\n\nWould you like help writing a full initialization function or configuring multiple frequencies dynamically?\n```"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2",
    "section": "",
    "text": "The purpose of lab 2 was to use time-multiplexing to drive two seven-segment displays based on inputs from two sets of four DIP switches using only one seven-segment display module. Additionally, the sum of the two displayed numbers is depicted in binary across five LEDs."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2",
    "section": "",
    "text": "The purpose of lab 2 was to use time-multiplexing to drive two seven-segment displays based on inputs from two sets of four DIP switches using only one seven-segment display module. Additionally, the sum of the two displayed numbers is depicted in binary across five LEDs."
  },
  {
    "objectID": "labs/lab2/lab2.html#schematic",
    "href": "labs/lab2/lab2.html#schematic",
    "title": "Lab 2",
    "section": "Schematic",
    "text": "Schematic\nThe circuit diagram to drive the two seven-segment displays and five LEDs based on eight input switches is as follows:\n\nThe calculations for resistors to control the current draw/sink on all FPGA pins are as follows:"
  },
  {
    "objectID": "labs/lab2/lab2.html#block-diagram",
    "href": "labs/lab2/lab2.html#block-diagram",
    "title": "Lab 2",
    "section": "Block Diagram",
    "text": "Block Diagram\nThe block diagram for the SystemVerilog modules used in this design is as follows:"
  },
  {
    "objectID": "labs/lab2/lab2.html#code",
    "href": "labs/lab2/lab2.html#code",
    "title": "Lab 2",
    "section": "Code:",
    "text": "Code:\nHere is the code implementation of the block diagram above:\n/*\nlab2_mk_top.sv\n\nDrives give LEDs and two 7-segment displays based on inputs from\neight switches. 7-segment displays count up from 0-F in hex based\non the binary value encoded by the state of the switches: the first four\ncorrespond to the first 7-segment display, and the second four switches to\nthe second 7-segment display. The five LEDs represent the sum of the values \nencoded by the two sets of four switches.\n\nMadeleine Kan\nmkan@hmc.edu\n7 September, 2025\n*/\n`timescale 1ns/1ns\nmodule lab2_mk_top(\n    input logic [3:0] s0, s1,\n    output logic [4:0] led,\n    output logic [6:0] seg,\n    output logic anode0, anode1\n);\n    logic clk, clk_div, anode0_int, anode1_int;\n    logic [4:0] led_int;\n    logic [6:0] seg_int;\n\n    // Internal high-speed oscillator\n    HSOSC #(.CLKHF_DIV(2'b01)) // 24MHz from clk divider\n     hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk));\n    \n    // Counter, changes ~91Hz\n    counter count(clk, clk_div);\n    led_driver driver(clk_div, s0, s1, led_int, seg_int, anode0_int, anode1_int);\n    \n    always_ff @(posedge clk) begin\n        anode0 &lt;= anode0_int;\n        anode1 &lt;= anode1_int;\n        led &lt;= led_int;\n        seg &lt;= seg_int;\n    end\n\nendmodule\n/*\ncounter.sv\n\nTakes in clk, clock signal\nOutputs clk_new, a new clock signal that rises every 2^N clk cycles\nMadeleine Kan\nmkan@hmc.edu\n3 September, 2025\n*/\n\nmodule counter #(parameter N = 17)\n     (input logic clk, reset\n     output logic clk_div);\n     \n    logic [N:0] counter;\n    always_ff @(posedge clk) begin\n        if (reset == 1'b1) begin // active low\n            counter &lt;= 1'b0;\n        end\n        else begin\n            counter &lt;= counter + 1'b1;\n        end\n    end\n    assign clk_div = counter[N]\nendmodule\n\n/*\nled_driver.sv\n\nDrives give LEDs and two 7-segment displays based on inputs from\neight switches. 7-segment displays count up from 0-F in hex based\non the binary value encoded by the state of the switches: the first four\ncorrespond to the first 7-segment display, and the second four switches to\nthe second 7-segment display. The five LEDs represent the sum of the values \nencoded by the two sets of four switches. Which set of switches (s0 or s1)\nare read and which 7-seg display is visible (depending on anode0 and anode1)\ndepends on if clk is 0 or 1\n\nMadeleine Kan\nmkan@hmc.edu\n9 September, 2025\n*/\n`timescale 1ns/1ns\nmodule led_driver(\n    input logic clk,\n    input logic [3:0] s0, s1,\n    output logic [4:0] led,\n    output logic [6:0] seg,\n    output logic anode0, anode1\n);\n    logic [3:0] s_in;\n    logic [6:0] seg_out;\n    \n    // Assign LED output\n    assign led = s0 + s1;\n    \n    // Mux input\n    mux mux0(s0, s1, clk, s_in); \n    // Feed input to seven_segment_display\n    seven_segment_display display0(s_in, seg_out);\n\n    // Control seven-segment display common anodes\n    assign anode0 = ~clk;\n    assign anode1 = clk;\n    \n    // drive seven-segment displays\n    assign seg = seg_out;\n    \nendmodule\n\n/*\nmux.sv\n\nSynchronous enabled mux with 2 inputs\nall inputs and outputs are 4 bits wide\n\nMadeleine Kan\nmkan@hmc.edu\n7 September, 2025\n*/\n\n`timescale 1ns/1ns\n\nmodule mux(\n    input logic [3:0] in0, [3:0] in1, \n    input logic en,\n    output logic [3:0] out);\n    \n    assign out =  en ? in1 : in0;\nendmodule\n/*\nseven_segment_display.sv\nDrives HDSP-521A Seven-Segment Display\nwith common anode (meaining diodes are\npulled to ground to activate)\nMadeleine Kan\nmkan@hmc.edu\n3 September, 2025\n*/\n\nmodule seven_segment_display(\n    input logic [3:0] s,\n    output logic [6:0] seg\n);\n    always_comb\n        case(s) \n            //                abcdefg\n            4'b0000: seg = 7'b0000001; // 0\n            4'b0001: seg = 7'b1001111; // 1\n            4'b0010: seg = 7'b0010010; // 2\n            4'b0011: seg = 7'b0000110; // 3\n            4'b0100: seg = 7'b1001100; // 4\n            4'b0101: seg = 7'b0100100; // 5\n            4'b0110: seg = 7'b0100000; // 6\n            4'b0111: seg = 7'b0001111; // 7\n            4'b1000: seg = 7'b0000000; // 8\n            4'b1001: seg = 7'b0001100; // 9\n            4'b1010: seg = 7'b0001000; // a\n            4'b1011: seg = 7'b1100000; // b\n            4'b1100: seg = 7'b0110001; // c\n            4'b1101: seg = 7'b1000010; // d\n            4'b1110: seg = 7'b0110000; // e\n            4'b1111: seg = 7'b0111000; // f\n            default: seg = 7'b1111111; // none\n        endcase\nendmodule"
  },
  {
    "objectID": "labs/lab2/lab2.html#results",
    "href": "labs/lab2/lab2.html#results",
    "title": "Lab 2",
    "section": "Results",
    "text": "Results\nThe design met all requirements, as demonstrated by the following testbench waveforms. Note: I struggled to validate the clock/oscillator functionality in simulation. While I can verify that it worked based on the hardware, I do need to work on developing testbenches for internal clock dependent components.\nLED_driver results: \nmux results: \nseven_segment_display results:"
  },
  {
    "objectID": "labs/lab2/lab2.html#summary",
    "href": "labs/lab2/lab2.html#summary",
    "title": "Lab 2",
    "section": "Summary",
    "text": "Summary\nThis lab took me ~20 hours. During it, I learned about the intricacies of synchronous design, both in hardware and in simulation. I also learned about important power considerations when driving circuits from an FPGA."
  },
  {
    "objectID": "labs/lab2/lab2.html#testbench-code",
    "href": "labs/lab2/lab2.html#testbench-code",
    "title": "Lab 2",
    "section": "Testbench Code",
    "text": "Testbench Code\nBelow is the code I used to validate my design.\n/*\nTestbench for led_driver.sv\n7 September 2025\nMadeleine Kan\nmkan@g.hmc.edu\n*/\n`timescale 1ns/1ns\n\nmodule led_driver_testbench();\n    logic clk;\n    logic [3:0] s0, s1, s_exp;\n    logic [4:0] led, led_exp;\n    logic [6:0] seg, seg_exp;\n    logic anode0, anode1, anode0_exp, anode1_exp;\n    logic [31:0] errors, vectornum;\n    logic [6:0] tv;\n    led_driver dut(clk, s0, s1, led, seg, anode0, anode1);\n    \n    initial\n        begin\n            errors=0;\n            vectornum=0;\n            for(tv=9'b000000000; tv&lt;=9'b111111111; tv = tv+1'b1) begin\n                clk = tv[0];\n                #1\n                s1 = tv[8:5];\n                s0 = tv[4:1];\n                assign led_exp = s0+s1;\n                assign anode0_exp = ~clk;\n                assign anode1_exp = clk;   \n                assign s_exp = clk?s1:s0;\n                #1\n                case(s_exp)\n                    //                abcdefg\n                    4'b0000: seg_exp = 7'b0000001; // 0\n                    4'b0001: seg_exp = 7'b1001111; // 1\n                    4'b0010: seg_exp = 7'b0010010; // 2\n                    4'b0011: seg_exp = 7'b0000110; // 3\n                    4'b0100: seg_exp = 7'b1001100; // 4\n                    4'b0101: seg_exp = 7'b0100100; // 5\n                    4'b0110: seg_exp = 7'b0100000; // 6\n                    4'b0111: seg_exp = 7'b0001111; // 7\n                    4'b1000: seg_exp = 7'b0000000; // 8\n                    4'b1001: seg_exp = 7'b0001100; // 9\n                    4'b1010: seg_exp = 7'b0001000; // a\n                    4'b1011: seg_exp = 7'b1100000; // b\n                    4'b1100: seg_exp = 7'b0110001; // c\n                    4'b1101: seg_exp = 7'b1000010; // d\n                    4'b1110: seg_exp = 7'b0110000; // e\n                    4'b1111: seg_exp = 7'b0111000; // f\n                    default: seg_exp = 7'b1111111; // none\n                endcase\n                #5;\n                assert({led, seg, anode0, anode1} === {led_exp, seg_exp, anode0_exp, anode1_exp}) else begin\n                    $display(\"Error: clk = %b, s0 = %b, s1 = %b\", clk, s0, s1);\n                    $display(\" outputs: (led, seg, anode0, anode1) = %b(%b expected)\", {led, seg, anode0, anode1}, {led_exp, seg_exp, anode0_exp, anode1_exp});\n                    errors = errors + 1;\n                end\n                if (tv == 7'b1111111) begin\n                    vectornum = vectornum + 1;\n                    $display(\"%d tests completed with %d errors\", vectornum, errors);\n                    $stop;\n                end\n                else begin\n                    vectornum = vectornum + 1;\n                end\n            end\n            $display(\"%d tests completed with %d errors\", vectornum, errors);\n            $stop;\n        end\nendmodule\n/*\nTestbench for mux.sv\n3-bit input, 1-bit output\n7 September 2025\nMadeleine Kan\nmkan@g.hmc.edu\n*/\n`timescale 1ns/1ns\n\nmodule mux_testbench();\n    logic [3:0] in0, in1;\n    logic en;\n    logic [3:0] out, out_exp;\n    logic [31:0] errors, vectornum;\n    logic [8:0] tv;\n    mux dut(in0, in1, en, out);\n    initial\n        begin\n            errors=0;\n            vectornum=0;\n            for(tv=9'b000000000; tv&lt;=9'b111111111; tv = tv+1'b1) begin\n                en = tv[0];\n                #5;\n                in1 = tv[8:5];\n                in0 = tv[4:1];\n                assign out_exp = en? in1 : in0;\n                #5;\n                assert(out == out_exp) else begin\n                    $display(\"Error: inputs = %b\", tv);\n                    $display(\" outputs = %b(%b expected)\", out, in1);\n                    errors = errors + 1;\n                end\n                if (tv == 9'b111111111) begin\n                    vectornum = vectornum + 1;\n                    $display(\"%d tests completed with %d errors\", vectornum, errors);\n                    $stop;\n                end\n                else begin\n                    vectornum = vectornum + 1;\n                end\n            end\n            $display(\"%d tests completed with %d errors\", vectornum, errors);\n            $stop;\n        end\nendmodule\n\n/*\nTestbench for seven_segment_display.sv\n4-bit input, 7-bit output\n3 September 2025\nMadeleine Kan\nmkan@g.hmc.edu\n*/\nmodule seven_segment_display_testbench();\n    logic clk, reset;\n    logic [3:0] s;\n    logic [6:0] seg, seg_exp;\n    logic [31:0] vectornum, errors;\n    logic [10:0] testvectors[10000:0];\n    seven_segment_display dut(s, seg);\n    always\n        begin\n            clk=1; #5; \n            clk=0; #5;\n        end\n    initial\n        begin\n            $readmemb(\"C:/Users/mkan/Documents/GitHub/e155-lab2/lab2/source/impl_1/seg_exp.tv\", testvectors);\n            vectornum=0; \n            errors=0;\n            reset=1; #5; \n            reset=0;\n        end\n    always @(posedge clk)\n        begin\n            #1;\n            {s, seg_exp} = testvectors[vectornum];\n        end\n    always @(negedge clk)\n        if (~reset) begin\n            if (seg !== seg_exp) begin\n                $display(\"Error: inputs = %b\", seg);\n                $display(\" outputs = %b(%b expected)\", seg, seg_exp);\n                errors = errors + 1;\n            end\n            vectornum = vectornum + 1;\n            if (testvectors[vectornum] === 11'bx) begin\n                $display(\"%d tests completed with %d errors\", vectornum, errors);\n                $stop;\n            end\n        end\nendmodule\nAdditionally, here is the seg_exp testvector file I referenced in the seven segment display testbench.\n// s[3:0]  seg_exp[6:0]\n0000_0000001\n0001_1001111\n0010_0010010\n0011_0000110\n0100_1001100\n0101_0100100\n0110_0100000\n0111_0001111\n1000_0000000\n1001_0001100\n1010_0001000\n1011_1100000\n1100_0110001\n1101_1000010\n1110_0110000\n1111_0111000"
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-reflection",
    "href": "labs/lab2/lab2.html#ai-reflection",
    "title": "Lab 2",
    "section": "AI reflection",
    "text": "AI reflection\nFirst, I prompted ChatGPT by saying ‚ÄúHello! Please write SystemVerilog HDL to time multiplex a single seven segment decoder (That decodes form four bits to a common anode seven segment dispaly) to decode two sets of input bits and drive two sets of seven output bits.‚Äù It responded with a brief explanation and the following code:\nmodule seven_segment_multiplexer (\n    input logic clk,\n    input logic rst,\n    input logic [3:0] data1,\n    input logic [3:0] data2,\n    output logic [6:0] segments,\n    output logic [1:0] anode\n);\n\n    // Internal signal to hold selected 4-bit input\n    logic [3:0] current_input;\n    logic       select_display;\n\n    // Toggle between displays\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            select_display &lt;= 0;\n        else\n            select_display &lt;= ~select_display;\n    end\n\n    // Select input based on current display\n    always_comb begin\n        case (select_display)\n            1'b0: begin\n                current_input = data1;\n                anode = 2'b10; // Activate first display (active low)\n            end\n            1'b1: begin\n                current_input = data2;\n                anode = 2'b01; // Activate second display (active low)\n            end\n        endcase\n    end\n\n    // Seven segment decoder (common anode: active low)\n    always_comb begin\n        case (current_input)\n            4'h0: segments = 7'b0000001;\n            4'h1: segments = 7'b1001111;\n            4'h2: segments = 7'b0010010;\n            4'h3: segments = 7'b0000110;\n            4'h4: segments = 7'b1001100;\n            4'h5: segments = 7'b0100100;\n            4'h6: segments = 7'b0100000;\n            4'h7: segments = 7'b0001111;\n            4'h8: segments = 7'b0000000;\n            4'h9: segments = 7'b0000100;\n            4'hA: segments = 7'b0001000;\n            4'hB: segments = 7'b1100000;\n            4'hC: segments = 7'b0110001;\n            4'hD: segments = 7'b1000010;\n            4'hE: segments = 7'b0110000;\n            4'hF: segments = 7'b0111000;\n            default: segments = 7'b1111111; // All segments off\n        endcase\n    end\n\nendmodule\nThis code looks pretty similar to what I ended up doing! I do think the code could be a bit more idiomatic ‚Äì for instance, using a mux instead of a case statement to driev the anodes ‚Äì to more directly reflect the inferred hardware. The use of a two-bit number for the anodes is different from what I chose, but it seems like a good design choice since it already takes care of the default case (ensuring that the two anodes are always opposite each other). The explanation was helpful, and ChatGPT included an important note about the desired clock frequency. In addition, the code compiled.\nAt this point, I had to log in and create a new conversation. I provided ChatGPT with the same prompt, appended with ‚Äúuse the seven segment decoder and oscillator provided in the attached filles‚Äù, and I attached my seven-segment decoder and count modules from lab1. This was exciting since I didn‚Äôt know that this was a feature of ChatGPT. In response to this prompt, ChatGPT provided the following code:\n\nIn accompaniment, ChatGPT also provided a good description of the modules I uploaded. The comments for this module were much more thorough than the comments from the first module. Perhaps this is because the modules I uploaded had descriptions at the top so ChatGPT copied that? Since I originally included HSOSC in the top module (instead of its own module), the code that ChatGPT wrote still requires a clk input, so the clk frequency remains unspecified. In general, the way the code was organized and the variables were named was different from what I would have chosen, but the design still seems fundamentally equivalent. Additionally, the code compiled on the first try, which was exciting."
  },
  {
    "objectID": "labs/lab2/lab2.html#resources",
    "href": "labs/lab2/lab2.html#resources",
    "title": "Lab 2",
    "section": "Resources",
    "text": "Resources\nLab Code\nSeven Segment display datasheet\nPNP transistor datasheet"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Here is Madeleine Kan‚Äôs portfolio for E155 coursework! Reports on the labs she completed can be found at the Labs Page, and a report on her and Sarah Yandell‚Äôs joint final project can be found at E155 Final Project: Spinning Synth.\nAbout Madeleine Kan is a senior engineering major at Harvey Mudd College. She is studying general engineering with a focus on computer engineering with biomedical applications. She has experience in supply chain process engineering, FPGA and microcontroller programming, and mechanical design and analysis. In the spring of 2025, she worked as part of the UC Berkeley clinic team to upgrade the communication protocol for a low-cost air quality sensor. Since the start of 2024, she has worked in the Quantum Quasars Lab to develop an astronomical random number generator for Bell-type tests of quantum entanglement. She also has tutored for a variety of engineering courses and labs. She is part of the CMS Swim team, specializing in sprint freestyle and butterfly. In her free time, she likes to crochet, learn the piano, and spend time with her friends and family."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "This is the blog section!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1 Reflection\n\n\nFPGA and MCU Setup and Testing\n\n\n\n\n\nSep 6, 2025\n\n\nMadeleine Kan\n\n\n\n\n\n\n\n\n\n\n\n\nInitial Reflection\n\n\nWhat I‚Äôm hoping to get out of MicroPs\n\n\n\n\n\nAug 29, 2025\n\n\nMadeleine Kan\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 27, 2025\n\n\nMadeleine Kan\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1",
    "section": "",
    "text": "The purpose of Lab1 was to assemble the PCB, establish a connection to the FPGA and MCU, and write a simple program to drive three LEDs as well as a seven-segment display simultaneously using four input switches."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1",
    "section": "",
    "text": "The purpose of Lab1 was to assemble the PCB, establish a connection to the FPGA and MCU, and write a simple program to drive three LEDs as well as a seven-segment display simultaneously using four input switches."
  },
  {
    "objectID": "labs/lab1/lab1.html#schematic",
    "href": "labs/lab1/lab1.html#schematic",
    "title": "Lab 1",
    "section": "Schematic",
    "text": "Schematic\nThe circuit diagram to drive the three LEDs and the seven-segment display using four input switches is as follows: \nThe calculations for the current draw of the seven-segment display are:  This is because the seven-segment display is being powered by 3.3V, and each diode within the display experiences a voltage drop of 2V. The resistor values of 330 Ohms I chose resulted in a current draw of 3.93 mA, which is less than the recommended range of 5mA-20mA, but the diodes still shone visibly while remaining well under the maximum allowed current of 20 mA. While different from what I ended up doing, 100 Ohm resistors could be used to yield a current of (1.3V/100 Ohms) = 13 mA, which is within the recommended operating range of the 7-segment display."
  },
  {
    "objectID": "labs/lab1/lab1.html#block-diagram",
    "href": "labs/lab1/lab1.html#block-diagram",
    "title": "Lab 1",
    "section": "Block Diagram",
    "text": "Block Diagram\nThe block diagram of the systemverilog code is:"
  },
  {
    "objectID": "labs/lab1/lab1.html#code",
    "href": "labs/lab1/lab1.html#code",
    "title": "Lab 1",
    "section": "Code",
    "text": "Code\nThe systemverilog code itself is:\n/*\nlab1_top.sv\n\nDrives three LEDs and a 7-segment display based on inputs from\nfour switches. 7-segment display counts up from 0-F in hex based\non the binary value encoded by the state of the switches.\nThe first LED is lit when the first two switches are pushed simulateously.\nThe second LED is lit when the third XOR the fourth switch is pulsed.\nThe third LED pulses at ~2.8 Hz.\n\nMadeleine Kan\nmkan@hmc.edu\n3 September, 2025\n*/\n\nmodule lab1_top(\n    input logic [3:0] s,\n    output logic [2:0] led,\n    output logic [6:0] seg\n);\n    logic clk_div;\n    logic [6:0] seg_out;\n    // Internal high-speed oscillator\n    HSOSC #(.CLKHF_DIV(2'b01)) // 24MHz from clk divider\n     hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk));\n    \n    // Counter\n    counter count(clk, clk_div);\n    \n    // 7-segment display\n    seven_segment_display display(s, seg_out);\n    \n    // Assign LED output\n    assign led[0] = s[0] & s[1];\n    assign led[1] = s[2] ^ s[3];\n    assign led[2] = clk_div;\n    assign seg = seg_out;\n    \nendmodule\n\n/*\ncounter.sv\n\nTakes in clk, clock signal\nOutputs clk_new, a new clock signal that rises every 2^23 clk cycles\nMadeleine Kan\nmkan@hmc.edu\n3 September, 2025\n*/\n\nmodule counter\n     (input logic clk,\n     output logic clk_new);\n     \n    logic [23:0] counter;\n    always_ff @(posedge clk)\n        counter &lt;= counter + 24'b1;\n    assign clk_new = counter[23];\nendmodule\n\n/*\nseven_segment_display.sv\nDrives HDSP-521A Seven-Segment Display\nwith common anode (meaining diodes are\npulled to ground to activate)\nMadeleine Kan\nmkan@hmc.edu\n3 September, 2025\n*/\n\n/*\nseven_segment_display.sv\nDrives HDSP-521A Seven-Segment Display\nwith common anode (meaining diodes are\npulled to ground to activate)\nMadeleine Kan\nmkan@hmc.edu\n3 September, 2025\n*/\n\nmodule seven_segment_display(\n    input logic [3:0] s,\n    output logic [6:0] seg\n);\n    always_comb\n        case(s) \n            //                abcdefg\n            4'b0000: seg = 7'b0000001; // 0\n            4'b0001: seg = 7'b1001111; // 1\n            4'b0010: seg = 7'b0010010; // 2\n            4'b0011: seg = 7'b0000110; // 3\n            4'b0100: seg = 7'b1001100; // 4\n            4'b0101: seg = 7'b0100100; // 5\n            4'b0110: seg = 7'b0100000; // 6\n            4'b0111: seg = 7'b0001110; // 7\n            4'b1000: seg = 7'b0000000; // 8\n            4'b1001: seg = 7'b0001100; // 9\n            4'b1010: seg = 7'b0001000; // a\n            4'b1011: seg = 7'b1100000; // b\n            4'b1100: seg = 7'b0110001; // c\n            4'b1101: seg = 7'b1000010; // d\n            4'b1110: seg = 7'b0110000; // e\n            4'b1111: seg = 7'b0111000; // f\n            default: seg = 7'b1111111; // none\n        endcase\nendmodule\nThe scratchwork to develop the truth table for the seven_segment_display module was:"
  },
  {
    "objectID": "labs/lab1/lab1.html#results",
    "href": "labs/lab1/lab1.html#results",
    "title": "Lab 1",
    "section": "Results",
    "text": "Results\nThe design met all intended design objectives, as verified by the following QuestaSim simulations:\nlab1_top testbench \nseven_segment_display testbench \nAs we can see, all of the testvectors passed the testbenches, demonstrating intended funcitonality of both modules.\nThis lab took me around 20 hours."
  },
  {
    "objectID": "labs/lab1/lab1.html#reflection",
    "href": "labs/lab1/lab1.html#reflection",
    "title": "Lab 1",
    "section": "Reflection",
    "text": "Reflection\nReflection before lab regrade:\nThis lab met all but one proficiency requirement, as specified in the Lab 1 spec sheet. The missing proficiency requirement is due to the missing 5V regulator and SMT diodes, which were not available in the digital lab at the time of completion. I will find and solder these on during the next week.\nIn terms of the excellence requirements, I provide calculations to show how to maintain the current draw in each diode of the seven-segment display within the recommended operating conditions of 5-20 mA. However, this differs slightly from what I ended up doing. This is because I noticed that the 3.3V output from my PCB was not working as intended; originally, it was outputting 1.4 V instead of 3.3V. I worked with Abe to attach a 3.3V regulator, but then the output started yielding &lt;1V. During this time, I decided to supply the seven-segment display with 5V, thus necessitating the higher resistor value. Later, I moved the entire circuit from the PCB to the breadboard, so I was able to use the 3.3V power source again. However, since I was limited on time, I did not change the resistors back from 330 Ohms to ~100 Ohms. Next week, I will be sure to start the lab earlier and schedule more time to work on it so I can perform more thorough organized work.\nThe other excellence requirement I did not meet was the QuestaSim automatic testbench requirement. I started working on a testbench and testvector for seven_segment_display.sv, but I ran into difficulty with reading in the test vectors, and I unfortunately ran out of time to debug this.\nWhile I didn‚Äôt get to complete automated testbenches myself before the check-in time, I did help some peers debug their testbenches, and I have a sense of how I would approach simulating my code for future labs.\nReflection post updating lab for regrade\nThis lab meets all proficiency and excellence specifications. The main issues I ran into were as follows:\n\nHardware issues with the 3.3V regulator\nFirmware issues; I forgot to (re)set the top-level module, so the 3 led pins ended up not being driven. This could be seen in the pin assignment window. Since the pins weren‚Äôt being driven, they were at 3.3V as a default, but this voltage dropped to 1.8V when the pin was connected to the LED. To fix this, I had to go under the project menu and set the appropriate module as the top-level module and resyntesize.\nThe testbench couldn‚Äôt read the testvector file; this was remedied by referencing the absolute path of the testvector file (rather than the relative path)."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype",
    "href": "labs/lab1/lab1.html#ai-prototype",
    "title": "Lab 1",
    "section": "AI Prototype",
    "text": "AI Prototype\nI gave ChatGPT this prompt:\nLLM prompt Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\nIt generated the following code, accompanied by a high-leve overview of how the clk frequency is customized:\nmodule led_blinker (\n    input logic clk,      // High-speed clock (e.g., 12 MHz)\n    output logic led      // LED output (blinking at 2 Hz)\n);\n\n    // Define a parameter for clock frequency and target frequency for blinking\n    parameter integer HIGH_SPEED_CLK_FREQ = 12000000;  // 12 MHz internal oscillator\n    parameter integer TARGET_FREQ = 1; // 1 Hz (for 2 Hz blinking)\n    \n    // Calculate the division factor (this depends on the input clock and target frequency)\n    localparam integer DIVIDE_FACTOR = HIGH_SPEED_CLK_FREQ / (TARGET_FREQ * 2); // Divide by 2 for full period\n\n    // Counter to divide the clock frequency\n    logic [31:0] counter;  // Counter to keep track of clock cycles\n\n    // Clock divider and LED toggle logic\n    always_ff @(posedge clk) begin\n        if (counter &lt; DIVIDE_FACTOR - 1) begin\n            counter &lt;= counter + 1;\n        end else begin\n            counter &lt;= 0;\n            led &lt;= ~led; // Toggle LED state on every period of the divided clock\n        end\n    end\n\nendmodule\nThe code did synthesize on the first try, which was good, and the description would have been helpful if customizing the frequency of a clock signal in system verilog was completely new to me. However, one issue is that ChatGPT hardcoded the internal clk frequency, and it didn‚Äôt actually interface with the Lattice UP5K HSOSC. It also did not include any resources where users could find information about the Lattice UP5K HSOSC, like the official documentation. Additionally, it doesn‚Äôt really talk about how the size of the counter vector (N) or the constant that is added to counter every clock cylce (p) can be adjusted to derive a desired clock frequency‚Äìit basically assumes that the only way to create a clock signal with a desired frequency is to find an internal clock that is already some power of 2 of that frequency. When I was writing the code to get an LED to blink at 2.4 Hz, I found reading the documentation for the HSOSC, referencing the formula for f_PWM from the E85 textbook, and referencing my old E85 code to be the most helpful. All three of these resources provided valuable information not covered by ChatGPT‚Äôs first response. If I were to use AI in my workflow, I would try to research what I‚Äôm trying to accomplish so that I can tune my prompt to get more valuable and detailed information."
  },
  {
    "objectID": "labs/lab1/lab1.html#reference",
    "href": "labs/lab1/lab1.html#reference",
    "title": "Lab 1",
    "section": "Reference",
    "text": "Reference\nCode can be found in this github repository"
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3",
    "section": "",
    "text": "The purpose of Lab3 was to develop a scanner to read two inputs from a keypad and display them on a seven-segment display."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab 3",
    "section": "",
    "text": "The purpose of Lab3 was to develop a scanner to read two inputs from a keypad and display them on a seven-segment display."
  },
  {
    "objectID": "labs/lab3/lab3.html#schematic",
    "href": "labs/lab3/lab3.html#schematic",
    "title": "Lab 3",
    "section": "Schematic",
    "text": "Schematic\nThe circuit diagram is as follows: \nThe calculations for the current-limiting resistors are as follows:  ## Block Diagram Here is the block diagram for the overall software architecture: \nHere is the ScanFSM state transition diagram: \nHere is the DebounceFSM state transition diagram:"
  },
  {
    "objectID": "labs/lab3/lab3.html#code",
    "href": "labs/lab3/lab3.html#code",
    "title": "Lab 3",
    "section": "Code:",
    "text": "Code:\nHere is the code implementation of the system described above:\nmodule lab3_top(\n    input logic reset,\n    input logic [3:0] row_in,\n    output logic [3:0] col_out,\n    output logic [6:0] seg,\n    output logic anode0, anode1, signal\n);\n    logic clk, clk_div, read;\n    logic [3:0] row_in_sync;\n    logic [3:0] num, num_out, num_old_out, num_out_next, num_old_out_next;\n    \n    // initialize default num values\n    /*\n    initial begin\n        num_out = 4'b0000;\n        num_old_out = 4'b0000;\n    end\n    */\n    \n    // Internal high-speed oscillator\n    HSOSC #(.CLKHF_DIV(2'b00)) // 48MHz from clk divider\n     hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk));\n     \n    // Divided counter, changes ~91Hz\n    counter #(18) clock_divider(clk, reset, clk_div);\n    \n    // Syncronizer\n    always_ff @(posedge clk)\n    if(~reset) begin\n        row_in_sync &lt;= 4'b0000;\n    end\n    else begin\n        row_in_sync &lt;= row_in;\n    end\n    \n    // Scan FSM ... IS IT OKAY FOR THIS TO BE ON DIVIDED CLK?\n    scan_fsm scanner(clk_div , reset, row_in_sync, col_out, signal);\n    \n    // debounce\n    // debounce_fsm debouncer(clk, reset, signal, read);\n    \n    \n    // led processor ... could refactor to take some stuff out of here\n    // and put it in a mux up front\n    led_processor process(row_in_sync, col_out, num);\n\n    // nextstate logic\n    always_comb\n        // active low\n        \n        // if reading signal\n        if(signal) begin // should be read\n            num_out_next = num;\n            num_old_out_next = num_out;\n        end\n        // if not reading signal, display the same  \n        else begin\n            num_out_next = num_out;\n            num_old_out_next = num_old_out;\n        end\n    \n    // flop\n    always_ff @(posedge clk)\n        if(~reset) begin\n            num_out &lt;= 4'b0000;\n            num_old_out &lt;= 4'b0000;\n        end\n        else begin\n            num_out &lt;= num_out_next;\n            num_old_out &lt;= num_old_out_next;\n        end\n        \n\n    // led driver\n    led_driver driver(clk_div, num_out, num_old_out, seg, anode0, anode1);\n\nendmodule\n/*\ncounter.sv\n\nTakes in clk, clock signal\nOutputs clk_new, a new clock signal that rises every 2^N clk cycles\nMadeleine Kan\nmkan@hmc.edu\n3 September, 2025\n*/\n\nmodule counter #(parameter N = 17)\n     (input logic clk, reset,\n     output logic clk_div);\n     \n    logic [N:0] counter;\n    always_ff @(posedge clk) begin\n        if (~reset) begin // active low\n            counter &lt;= 1'b0;\n        end\n        else begin\n            counter &lt;= counter + 1'b1;\n        end\n    end\n    assign clk_div = counter[N];\nendmodule\nmodule scan_fsm\n    (input logic clk_div, reset,\n    input logic [3:0] row_in,\n    output logic [3:0] col,\n    output logic signal\n    );\n    \n    // logic clk_div;\n    typedef enum logic [8:0] {start, check0, check1, check2, check3, signal0, signal1, signal2, signal3} statetype;\n    statetype state, nextstate;\n    // 750 kHz divided clock\n    // counter #(6) scan_clk(clk, reset, clk_div);\n    \n    \n    // state register\n    always_ff @(posedge clk_div)\n        if (~reset) state &lt;= start;\n        else state &lt;= nextstate;\n    \n    // state transition + output logic\n    always_comb\n        case(state)\n            start: begin\n                nextstate = check0;\n                col = 4'b0000;\n                signal = 1'b0;\n            end\n            check0: begin\n                if (row_in == 4'b0000) nextstate = check1;\n                else nextstate = signal0;\n                col = 4'b0001;\n                signal = 1'b0;\n            end\n            check1: begin\n                if (row_in == 4'b0000) nextstate = check2;\n                else nextstate = signal1;\n                col = 4'b0010;\n                signal = 1'b0;\n            end\n            check2: begin\n                if (row_in == 4'b0000) nextstate = check3;\n                else nextstate = signal2;\n                col = 4'b0100;\n                signal = 1'b0;\n            end\n            check3: begin\n                if (row_in == 4'b0000) nextstate = check0;\n                else nextstate = signal3;\n                col = 4'b1000;\n                signal = 1'b0;\n            end\n            signal0: begin\n                if (row_in == 4'b0000) nextstate = check1;\n                else nextstate = signal0;\n                col = 4'b0001;\n                signal = 1'b1;\n            end\n            signal1: begin\n                if (row_in == 4'b0000) nextstate = check2;\n                else nextstate = signal1;\n                col = 4'b0010;\n                signal = 1'b1;\n            end\n            signal2: begin\n                if (row_in == 4'b0000) nextstate = check3;\n                else nextstate = signal2;\n                col = 4'b0100;\n                signal = 1'b1;\n            end\n            signal3: begin\n                if (row_in == 4'b0000) nextstate = check0;\n                else nextstate = signal3;\n                col = 4'b1000;\n                signal = 1'b1;\n            end\n            default: begin\n                nextstate = start;\n                col = 4'b0000;\n                signal = 1'b1;\n            end\n        endcase\n        \nendmodule\n/*\ndebounce_fsm.sv\n\nFSM that waits ~50 msec after recieving an input signal\nfor the signal to stabilize. Outputs read=1 if, after 50 msec,\nthe input signal is still high. Otherwise, outputs read=0.\n\nMadeleine Kan\nmkan@hmc.edu\n16 September, 2025\n*/\nmodule debounce_fsm(\n    input logic clk, reset, signal,\n    output logic read);\n    \n    logic tryToRead, clk_div;\n    typedef enum logic [4:0] {idle, count, readSignal, unReadSignal, noSignal} statetype;\n    statetype state, nextstate;\n    \n    // 11.44 Hz divided clock -&gt; 43.69 msec until clk_div reaches 1\n    // resets on signal\n    counter #(21) scan_clk(clk, signal, clk_div);\n    \n    // state register\n    always_ff @(posedge clk)\n        if (~reset) state &lt;= idle;\n        else state &lt;= nextstate;\n        // tryToRead &lt;= signal;\n        // logic tryToRead &lt;= row_in_sync == row;\n    \n    // state transition logic\n    always_comb\n        case(state)\n            idle: if (signal) nextstate = count;\n                else nextstate = idle;\n            count: if (clk_div && signal) nextstate = readSignal;\n                    else if (clk_div && (!signal)) nextstate = noSignal;\n                    else nextstate = count;\n                    // // previously had the following code:\n                    // else if (signal) nextstate = count;\n                    // else nextstate = idle;\n                    // // I took it out in case the signal goes low\n                    // // in the 50 msec due to debouncing\n            readSignal: nextstate = unReadSignal;\n            unReadSignal: if (signal) nextstate = unReadSignal;\n                            else nextstate = idle;\n            noSignal: nextstate = idle;\n            default: nextstate = idle;\n        endcase\n        \n    // output logic\n    assign read = (state === readSignal);\n    \n    \nendmodule\n\n/*\nled_processor.sv\n\nCombinational module, takes in the activated row and column of \nthe 4x4 numpad and otuputs the number corresponding to that button.\nDepends on the layout of the 4x4 numpad.\n\nMadeleine Kan\nmkan@hmc.edu\n16 September, 2025\n*/\n`timescale 1ns/1ns\n\nmodule led_processor(\n    input logic [3:0] row, col,\n    output logic [3:0] num\n);\n    always_comb\n        case({row, col})\n            8'b00010001: num = 4'h1;\n            8'b00010010: num = 4'h2;\n            8'b00010100: num = 4'h3;\n            8'b00011000: num = 4'hA;\n            8'b00100001: num = 4'h4;\n            8'b00100010: num = 4'h5;\n            8'b00100100: num = 4'h6;\n            8'b00101000: num = 4'hB;\n            8'b01000001: num = 4'h7;\n            8'b01000010: num = 4'h8;\n            8'b01000100: num = 4'h9;\n            8'b01001000: num = 4'hC;\n            8'b10000001: num = 4'hE;\n            8'b10000010: num = 4'h0;\n            8'b10000100: num = 4'hF;\n            8'b10001000: num = 4'hD;\n            default: num = 4'b1111;\n        endcase\nendmodule\n\n//  typedef enum logic [2:0] {idle, process} statetype;\n//  statetype state, nextstate;\n    \n//  // state register\n//  always_ff @(posedge clk)\n//      if (~reset) state &lt;= idle;\n//      else state &lt;= nextstate;\n    \n//  // state transition + output logic\n//  always_comb\n//      case(state)\n//          idle: if (read) nextstate = process;\n//                  else nextstate = idle;\n//          process: nextstate = idle;\n//          default: nextstate = idle;\n//      endcase\n    \n//  // output logic\n//  always_comb\n//      if (state == process) begin\n//          case({row, col})\n//              8'b00010001: num_out = 4'h1;\n//              8'b00010010: num_out = 4'h2;\n//              8'b00010100: num_out = 4'h3;\n//              8'b00011000: num_out = 4'hA;\n//              8'b00100001: num_out = 4'h4;\n//              8'b00100010: num_out = 4'h5;\n//              8'b00100100: num_out = 4'h6;\n//              8'b00101000: num_out = 4'hB;\n//              8'b01000001: num_out = 4'h7;\n//              8'b01000010: num_out = 4'h8;\n//              8'b01000100: num_out = 4'h9;\n//              8'b01001000: num_out = 4'hC;\n//              8'b10000001: num_out = 4'hE;\n//              8'b10000010: num_out = 4'h0;\n//              8'b10000100: num_out = 4'hF;\n//              8'b10001000: num_out = 4'hD;\n//              default: num_out = 4'b1111;\n//              endcase\n//          num_old_out = num_in;\n//          end\n//      // maybe replace this logic with enabled flop outside of function\n//      // so like .. combinational module and enabled flop outside\n//      else begin\n//          num_out = num_in;\n//          num_old_out = num_old_in;\n//      end\n    \n// endmodule\n\n/*\nled_driver.sv\n\nDrives give LEDs and two 7-segment displays based on inputs from\neight switches. 7-segment displays count up from 0-F in hex based\non the binary value encoded by the state of the switches: the first four\ncorrespond to the first 7-segment display, and the second four switches to\nthe second 7-segment display. Which set of switches (s0 or s1)\nare read and which 7-seg display is visible (depending on anode0 and anode1)\ndepends on if clk is 0 or 1\n\nMadeleine Kan\nmkan@hmc.edu\n9 September, 2025\n*/\n`timescale 1ns/1ns\nmodule led_driver(\n    input logic clk_div,\n    input logic [3:0] s0, s1,\n    output logic [6:0] seg,\n    output logic anode0, anode1\n);\n    logic [3:0] s_in;\n    logic [6:0] seg_out;\n    \n    // Mux input\n    mux mux0(s0, s1, clk_div, s_in); \n    // Feed input to seven_segment_display\n    seven_segment_display display0(s_in, seg_out);\n\n    // Control seven-segment display common anodes\n    assign anode0 = ~clk_div;\n    assign anode1 = clk_div;\n    \n    // drive seven-segment displays\n    assign seg = seg_out;\n    \n    \n    \nendmodule\n/*\nmux.sv\n\nSynchronous enabled mux with 2 inputs\nall inputs and outputs are 4 bits wide\n\nMadeleine Kan\nmkan@hmc.edu\n7 September, 2025\n*/\n\n`timescale 1ns/1ns\n\nmodule mux(\n    input logic [3:0] in0, [3:0] in1, \n    input logic en,\n    output logic [3:0] out);\n    \n    assign out =  en ? in1 : in0;\nendmodule\n/*\nseven_segment_display.sv\nDrives HDSP-521A Seven-Segment Display\nwith common anode (meaining diodes are\npulled to ground to activate)\nMadeleine Kan\nmkan@hmc.edu\n3 September, 2025\n*/\n\nmodule seven_segment_display(\n    input logic [3:0] s,\n    output logic [6:0] seg\n);\n    always_comb\n        case(s) \n            //                abcdefg\n            4'b0000: seg = 7'b0000001; // 0\n            4'b0001: seg = 7'b1001111; // 1\n            4'b0010: seg = 7'b0010010; // 2\n            4'b0011: seg = 7'b0000110; // 3\n            4'b0100: seg = 7'b1001100; // 4\n            4'b0101: seg = 7'b0100100; // 5\n            4'b0110: seg = 7'b0100000; // 6\n            4'b0111: seg = 7'b0001111; // 7\n            4'b1000: seg = 7'b0000000; // 8\n            4'b1001: seg = 7'b0001100; // 9\n            4'b1010: seg = 7'b0001000; // a\n            4'b1011: seg = 7'b1100000; // b\n            4'b1100: seg = 7'b0110001; // c\n            4'b1101: seg = 7'b1000010; // d\n            4'b1110: seg = 7'b0110000; // e\n            4'b1111: seg = 7'b0111000; // f\n            default: seg = 7'b1111111; // none\n        endcase\nendmodule"
  },
  {
    "objectID": "labs/lab3/lab3.html#results",
    "href": "labs/lab3/lab3.html#results",
    "title": "Lab 3",
    "section": "Results",
    "text": "Results\nUnfortunately, the hardware design did not work. However, the simulations did work! Here are the waveforms: lab3_top testbench:\ntop-level testbench (didn‚Äôt fully work due to timing issues): \ncounter testbench: \nscan_fsm testbench: \ndebounce_fsm testbench:  \nled_processor testbench:  \nled_driver testbench: \nmux testbench: \nseven_segment_display testbench:"
  },
  {
    "objectID": "labs/lab3/lab3.html#summary",
    "href": "labs/lab3/lab3.html#summary",
    "title": "Lab 3",
    "section": "Summary",
    "text": "Summary\nI have so far spent ~30 hours on this lab. I learned a lot about synchrounous design and partitioning complicated tasks into simultaneous finite state machines."
  },
  {
    "objectID": "labs/lab3/lab3.html#testbench-code",
    "href": "labs/lab3/lab3.html#testbench-code",
    "title": "Lab 3",
    "section": "Testbench Code",
    "text": "Testbench Code\n/*\nTestbench for lab3_top.sv\n16 September 2025\nMadeleine Kan\nmkan@g.hmc.edu\n*/\n`timescale 1ns/1ns\n\nmodule lab3_top_testbench();\n    logic reset;\n    logic [3:0] row_in;\n    logic [3:0] col_out, col_exp;\n    logic [6:0] seg, seg_exp;\n    logic anode0, anode0_exp, anode1, anode1_exp;\n    logic [31:0] errors;\n    lab3_top dut(reset, row_in, col_out, seg, anode0, anode1);\n\n    initial begin\n        errors=0;\n        // toggle reset, so clk_div starts at 0\n        reset = 0; #21;\n        reset = 1;\n        #1;\n        row_in=4'b0000;\n        \n        // #2621440; // 5*2^19\n        // clk_div runs at 48MHz/(2^19)\n        // seg = (equivalent of 0), col=0000, anode0 = 1, anode1 = 0\n        seg_exp = 7'b0000001;\n        col_exp = 4'b0000;\n        anode0_exp = 1'b1;\n        anode1_exp = 1'b0;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg =0\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n        // #2621440; // 5*2^19\n        #500000;\n        \n        // wait for clk_div to rise ,  no inputs\n        #5242880; // 10*2^19\n        // here, fsm should be in ???\n        // seg = (equivalent of 0), col=0000 anode0 = 0, anode1 = 1\n        seg_exp = 7'b0000001;\n        col_exp = 4'b0000;\n        anode0_exp = 1'b0;\n        anode1_exp = 1'b1;\n        // #2621440;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg =0\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n\n        // wait for clk_div to rise again, still no inputs\n        #5242880; // 10*2^19\n        // here, fsm should be in start\n        // seg = (equivalent of 0), col=0000, anode0 = 1, anode1 = 0\n        seg_exp = 7'b0000001;\n        col_exp = 4'b0000;\n        anode0_exp = 1'b1;\n        anode1_exp = 1'b0;\n        #5;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg =0\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n          // wait for clk_div to rise again, still no inputs\n        #5242880; // 10*2^19\n        // here, fsm should be in check0\n        // seg = (equivalent of 0), col=0000, anode0 = 1, anode1 = 0\n        seg_exp = 7'b0000001;\n        col_exp = 4'b0000;\n        anode0_exp = 1'b0;\n        anode1_exp = 1'b1;\n        #5;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg =0\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n        \n        row_in=4'b0001;\n        // wait for clk_div to rise again, now with input\n        #5242880; // 10*2^19 \n        // should be more than enough time for the clk to rise (for syncrhonizer)\n        // here, fsm should be in signal0\n        // seg = (equivalent of 0), col=0001, anode0 = 0, anode1 = 1\n        seg_exp = 7'b0000001;\n        col_exp = 4'b0001;\n        anode0_exp = 1'b1;\n        anode1_exp = 1'b0;\n        #5;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg =0\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n \n        // here, read should = 1, so debounce_clk_div should start incrementing\n        // wait for debounce_fsm clk_div to rise (ie 50 ms) so that num can get the value 1\n        // this will take less long than the time until the next rising clk_div edge\n        // #10485760 // 5*2^21\n        // #1000005 // wait for clk to rise \n        #5242880; // 10*2^19 \n        // fsm should still be in signal0\n        // seg = 1001111 (equivalent of 1), col=0001, anode0 = 1, anode1 = 0\n        // determine if led clk_div is 0 or 1. The following assumes it is 1\n        seg_exp = 7'b1001111;\n        col_exp = 4'b0001;\n        anode0_exp = 1'b0;\n        anode1_exp = 1'b1;\n        #5;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg = 1\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n        \n        row_in=4'b0000;\n        // wait for clk_div to rise again, now with no input, check that seg toggles with 0 \n        #5242880; // 10*2^19 \n        // fsm should be in start\n        // seg = (equivalent of 0), col=0001, anode0 = 0, anode1 = 1\n        seg_exp = 7'b0000001;\n        col_exp = 4'b0001;\n        anode0_exp = 1'b1;\n        anode1_exp = 1'b0;\n        #5;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg = 0\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n        #5242880; // 10*2^19 \n        // wait for clk_div to rise again, check that seg holds & toggles with 1\n        #5242880; // 10*2^19 \n        // fsm should be in check1\n        // seg = (equivalent of 0), col=0001, anode0 = 0, anode1 = 1\n        seg_exp = 7'b1001111;\n        col_exp = 4'b0010;\n        anode0_exp = 1'b0;\n        anode1_exp = 1'b1;\n        #5;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg = 1\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n        #1;\n \n    $display(\"7 tests completed with %d errors\", errors);\n    $stop;\n    end\nendmodule\n/*\nTestbench for lab3_top.sv\n16 September 2025\nMadeleine Kan\nmkan@g.hmc.edu\n*/\n`timescale 1ns/1ns\n\nmodule lab3_top_testbench();\n    logic reset;\n    logic [3:0] row_in;\n    logic [3:0] col_out, col_exp;\n    logic [6:0] seg, seg_exp;\n    logic anode0, anode0_exp, anode1, anode1_exp;\n    logic [31:0] errors;\n    lab3_top dut(reset, row_in, col_out, seg, anode0, anode1);\n\n    initial begin\n        errors=0;\n        // toggle reset, so clk_div starts at 0\n        reset = 0; #21;\n        reset = 1;\n        #1;\n        row_in=4'b0000;\n        \n        // #2621440; // 5*2^19\n        // clk_div runs at 48MHz/(2^19)\n        // seg = (equivalent of 0), col=0000, anode0 = 1, anode1 = 0\n        seg_exp = 7'b0000001;\n        col_exp = 4'b0000;\n        anode0_exp = 1'b1;\n        anode1_exp = 1'b0;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg =0\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n        // #2621440; // 5*2^19\n        #500000;\n        \n        // wait for clk_div to rise ,  no inputs\n        #5242880; // 10*2^19\n        // here, fsm should be in ???\n        // seg = (equivalent of 0), col=0000 anode0 = 0, anode1 = 1\n        seg_exp = 7'b0000001;\n        col_exp = 4'b0000;\n        anode0_exp = 1'b0;\n        anode1_exp = 1'b1;\n        // #2621440;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg =0\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n\n        // wait for clk_div to rise again, still no inputs\n        #5242880; // 10*2^19\n        // here, fsm should be in start\n        // seg = (equivalent of 0), col=0000, anode0 = 1, anode1 = 0\n        seg_exp = 7'b0000001;\n        col_exp = 4'b0000;\n        anode0_exp = 1'b1;\n        anode1_exp = 1'b0;\n        #5;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg =0\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n          // wait for clk_div to rise again, still no inputs\n        #5242880; // 10*2^19\n        // here, fsm should be in check0\n        // seg = (equivalent of 0), col=0000, anode0 = 1, anode1 = 0\n        seg_exp = 7'b0000001;\n        col_exp = 4'b0000;\n        anode0_exp = 1'b0;\n        anode1_exp = 1'b1;\n        #5;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg =0\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n        \n        row_in=4'b0001;\n        // wait for clk_div to rise again, now with input\n        #5242880; // 10*2^19 \n        // should be more than enough time for the clk to rise (for syncrhonizer)\n        // here, fsm should be in signal0\n        // seg = (equivalent of 0), col=0001, anode0 = 0, anode1 = 1\n        seg_exp = 7'b0000001;\n        col_exp = 4'b0001;\n        anode0_exp = 1'b1;\n        anode1_exp = 1'b0;\n        #5;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg =0\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n \n        // here, read should = 1, so debounce_clk_div should start incrementing\n        // wait for debounce_fsm clk_div to rise (ie 50 ms) so that num can get the value 1\n        // this will take less long than the time until the next rising clk_div edge\n        // #10485760 // 5*2^21\n        // #1000005 // wait for clk to rise \n        #5242880; // 10*2^19 \n        // fsm should still be in signal0\n        // seg = 1001111 (equivalent of 1), col=0001, anode0 = 1, anode1 = 0\n        // determine if led clk_div is 0 or 1. The following assumes it is 1\n        seg_exp = 7'b1001111;\n        col_exp = 4'b0001;\n        anode0_exp = 1'b0;\n        anode1_exp = 1'b1;\n        #5;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg = 1\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n        \n        row_in=4'b0000;\n        // wait for clk_div to rise again, now with no input, check that seg toggles with 0 \n        #5242880; // 10*2^19 \n        // fsm should be in start\n        // seg = (equivalent of 0), col=0001, anode0 = 0, anode1 = 1\n        seg_exp = 7'b0000001;\n        col_exp = 4'b0001;\n        anode0_exp = 1'b1;\n        anode1_exp = 1'b0;\n        #5;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg = 0\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n        #5242880; // 10*2^19 \n        // wait for clk_div to rise again, check that seg holds & toggles with 1\n        #5242880; // 10*2^19 \n        // fsm should be in check1\n        // seg = (equivalent of 0), col=0001, anode0 = 0, anode1 = 1\n        seg_exp = 7'b1001111;\n        col_exp = 4'b0010;\n        anode0_exp = 1'b0;\n        anode1_exp = 1'b1;\n        #5;\n        assert((seg === seg_exp) && (col_out === col_exp) && (anode0===anode0_exp) && (anode1===anode1_exp)) else begin // seg = 1\n            $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n            $display(\" outputs: col = %b , (%b expected), seg = %b (%b expected), anode0,1 = %b (%b expected)\", col_out, col_exp, seg, seg_exp, {anode0, anode1}, {anode0_exp, anode1_exp});\n            errors = errors + 1;\n        end\n        #1;\n \n    $display(\"7 tests completed with %d errors\", errors);\n    $stop;\n    end\nendmodule\n/*\nTestbench for counter.sv\n1 bit input, 1 bit output, output flips after 2^17 cycles of the input.\n3 September 2025\nMadeleine Kan\nmkan@g.hmc.edu\n*/\nmodule counter_testbench();\n    logic clk, reset, clk_div;\n    counter #(17) dut(clk, reset, clk_div);\n    always\n        begin\n            clk=1; #5; \n            clk=0; #5;\n        end\n    initial begin\n        reset=0; #5; \n        reset=1;\n        #7\n        assert(clk_div == 1'b0) else $display(\"Error: inputs = %b\", clk, \" outputs = %b(0 expected)\", clk_div);\n        // #655365; // 5*2^17 + 5\n        #1310725 // 10*2^17+5\n        assert(clk_div == 1'b1) else $display(\"Error: inputs = %b\", clk, \" outputs = %b(1 expected)\", clk_div);\n        $display(\"tests completed!\");\n        $stop;\n    end\nendmodule\n/*\nTestbench for scan_fsm.sv\n\n16 September 2025\nMadeleine Kan\nmkan@g.hmc.edu\n*/\n`timescale 1ns/1ns\n\nmodule scan_fsm_testbench();\n    logic clk, reset;\n    logic [3:0] row_in;\n    logic [3:0] col, col_exp;\n    logic signal, signal_exp;\n    logic [31:0] vectornum, errors;\n    logic [9:0] testvectors [10000:0];\n\n    scan_fsm dut(clk, reset, row_in, col, signal);\n\n    always begin\n        clk = 1; #5;\n        clk = 0; #5; \n    end\n\n    initial\n        begin  \n            $readmemb(\"C:/Users/mkan/Documents/GitHub/e155-lab3/lab3/source/source/scan_fsm.tv\", testvectors);\n            vectornum = 0;\n            errors = 0;\n            // reset = 0; #21;\n            // reset = 1;\n        end\n    \n    always @(posedge clk)\n        begin\n            #1;\n            {reset, row_in, col_exp, signal_exp} = testvectors[vectornum];\n            // #640; // 10*2^6\n        end\n    \n    always @(negedge clk)\n        begin\n            assert((col_exp === col) && (signal_exp === signal)) else begin\n                $display(\"Error: row_in = %b , reset = %b \", row_in, reset);\n                $display(\" outputs: col = %b , (%b expected), signal = %b (%b expected)\", col, col_exp, signal, signal_exp);\n                errors = errors + 1;\n            end\n        vectornum = vectornum + 1;\n        // #1280; // 10*2^6\n        if (testvectors[vectornum] === 10'bx) begin\n            $display(\"%d tests completed with %d errors\", vectornum, errors);\n            $stop;\n        end\n        end\nendmodule\n/*\nTestbench for debounce.sv\n16 September 2025\nMadeleine Kan\nmkan@g.hmc.edu\n*/\n`timescale 1ns/1ns\n\nmodule debounce_fsm_testbench();\n    logic clk, reset, signal;\n    logic read;\n    logic [31:0] errors;\n    //logic [3:0] tv;\n    debounce_fsm dut(clk, reset, signal, read);\n\n    always begin\n        clk = 1; #5;\n        clk = 0; #5; \n    end\n\n    initial begin\n        errors=0;\n        reset = 0; #21;\n        reset = 1;\n        #1\n        // start in idle state\n        signal = 0;\n        #10\n        assert(read === 0) else begin\n            errors = errors+1;\n            $display(\"Error: read = %b, 0 expected\", read);\n        end\n        #1\n\n        // get signal, start in idle state\n        signal = 1;\n        #10\n        assert(read === 0) else begin\n            errors = errors+1;\n            $display(\"Error: read = %b, 0 expected\", read);\n        end\n        #20971520 // wait 2^21 - 10 cycles (10*2^21 - 15)\n\n        // move to readSignal state\n        assert(read === 1) else begin\n            errors = errors+1;\n            $display(\"Error: read = %b, 1 expected\", read);\n        end\n\n        // wait another clock cycle, return to idle\n        #11\n        assert(read === 0) else begin\n            errors = errors+1;\n            $display(\"Error: read = %b, 0 expected\", read);\n        end\n        #1\n        signal = 0;\n        #20971525 // wait 2^21 cycles (10*2^21 + 5)#10\n\n        // stay at idle bc no signal\n        assert(read === 0) else begin\n            errors = errors+1;\n            $display(\"Error: read = %b, 1 expected\", read);\n        end\n        signal = 0;\n        #10\n        assert(read === 0) else begin\n            errors = errors+1;\n            $display(\"Error: read = %b, 1 expected\", read);\n        end\n        \n        $display(\"6 tests completed with %d errors\", errors);\n        $stop;\n    end\nendmodule\n/*\nTestbench for led_processor.sv\ntwo 4-bit inputs, 4-bit output\n16 September 2025\nMadeleine Kan\nmkan@g.hmc.edu\n*/\n`timescale 1ns/1ns\n\nmodule led_processor_testbench();\n    logic [3:0] row, col;\n    logic [3:0] num, num_exp;\n    logic [31:0] errors, vectornum;\n    logic [7:0] tv;\n    led_processor dut(row, col, num);\n    \n    initial\n        begin\n            errors=0;\n            vectornum=0;\n            for(tv=8'b00000000; tv&lt;=8'b11111111; tv = tv+1'b1) begin\n                row = tv[7:4];\n                col = tv[3:0];\n                vectornum = vectornum + 1;\n                #1\n                case({row, col})\n                     8'b00010001: num_exp = 4'h1;\n                    8'b00010010: num_exp = 4'h2;\n                    8'b00010100: num_exp = 4'h3;\n                    8'b00011000: num_exp = 4'hA;\n                    8'b00100001: num_exp = 4'h4;\n                    8'b00100010: num_exp = 4'h5;\n                    8'b00100100: num_exp = 4'h6;\n                    8'b00101000: num_exp = 4'hB;\n                    8'b01000001: num_exp = 4'h7;\n                    8'b01000010: num_exp = 4'h8;\n                    8'b01000100: num_exp = 4'h9;\n                    8'b01001000: num_exp = 4'hC;\n                    8'b10000001: num_exp = 4'hE;\n                    8'b10000010: num_exp = 4'h0;\n                    8'b10000100: num_exp = 4'hF;\n                    8'b10001000: num_exp = 4'hD;\n                    default: num_exp = 4'b1111;\n                endcase\n                #5;\n                assert(num === num_exp) else begin\n                    $display(\"Error: row = %b, col = %b\", row, col);\n                    $display(\" output: num = %b(%b expected)\", num, num_exp);\n                    errors = errors + 1;\n                end\n                if (tv == 8'b11111111) begin\n                    vectornum = vectornum + 1;\n                    $display(\"%d tests completed with %d errors\", vectornum, errors);\n                    $stop;\n                end\n            end\n            $display(\"%d tests completed with %d errors\", vectornum, errors);\n            $stop;\n        end\nendmodule\n/*\nTestbench for led_driver.sv\n3-bit input, 1-bit output\n7 September 2025\nMadeleine Kan\nmkan@g.hmc.edu\n*/\n`timescale 1ns/1ns\n\nmodule led_driver_testbench();\n    logic clk_div;\n    logic [3:0] s0, s1, s_exp;\n    logic [4:0] led, led_exp;\n    logic [6:0] seg, seg_exp;\n    logic anode0, anode1, anode0_exp, anode1_exp;\n    logic [31:0] errors, vectornum;\n    logic [6:0] tv;\n    led_driver dut(clk_div, s0, s1, led, seg, anode0, anode1);\n    \n    initial\n        begin\n            errors=0;\n            vectornum=0;\n            for(tv=9'b000000000; tv&lt;=9'b111111111; tv = tv+1'b1) begin\n                clk_div = tv[0];\n                #1\n                s1 = tv[8:5];\n                s0 = tv[4:1];\n                assign led_exp = s0+s1;\n                assign anode0_exp = ~clk_div;\n                assign anode1_exp = clk_div;   \n                assign s_exp = clk_div?s1:s0;\n                #1\n                case(s_exp)\n                    //                abcdefg\n                    4'b0000: seg_exp = 7'b0000001; // 0\n                    4'b0001: seg_exp = 7'b1001111; // 1\n                    4'b0010: seg_exp = 7'b0010010; // 2\n                    4'b0011: seg_exp = 7'b0000110; // 3\n                    4'b0100: seg_exp = 7'b1001100; // 4\n                    4'b0101: seg_exp = 7'b0100100; // 5\n                    4'b0110: seg_exp = 7'b0100000; // 6\n                    4'b0111: seg_exp = 7'b0001111; // 7\n                    4'b1000: seg_exp = 7'b0000000; // 8\n                    4'b1001: seg_exp = 7'b0001100; // 9\n                    4'b1010: seg_exp = 7'b0001000; // a\n                    4'b1011: seg_exp = 7'b1100000; // b\n                    4'b1100: seg_exp = 7'b0110001; // c\n                    4'b1101: seg_exp = 7'b1000010; // d\n                    4'b1110: seg_exp = 7'b0110000; // e\n                    4'b1111: seg_exp = 7'b0111000; // f\n                    default: seg_exp = 7'b1111111; // none\n                endcase\n                #5;\n                assert({led, seg, anode0, anode1} === {led_exp, seg_exp, anode0_exp, anode1_exp}) else begin\n                    $display(\"Error: clk_div = %b, s0 = %b, s1 = %b\", clk_div, s0, s1);\n                    $display(\" outputs: (led, seg, anode0, anode1) = %b(%b expected)\", {led, seg, anode0, anode1}, {led_exp, seg_exp, anode0_exp, anode1_exp});\n                    errors = errors + 1;\n                end\n                if (tv == 7'b1111111) begin\n                    vectornum = vectornum + 1;\n                    $display(\"%d tests completed with %d errors\", vectornum, errors);\n                    $stop;\n                end\n                else begin\n                    vectornum = vectornum + 1;\n                end\n            end\n            $display(\"%d tests completed with %d errors\", vectornum, errors);\n            $stop;\n        end\nendmodule\n/*\nTestbench for mux.sv\n3-bit input, 1-bit output\n7 September 2025\nMadeleine Kan\nmkan@g.hmc.edu\n*/\n`timescale 1ns/1ns\n\nmodule mux_testbench();\n    logic [3:0] in0, in1;\n    logic en;\n    logic [3:0] out, out_exp;\n    logic [31:0] errors, vectornum;\n    logic [8:0] tv;\n    mux dut(in0, in1, en, out);\n    initial\n        begin\n            errors=0;\n            vectornum=0;\n            for(tv=9'b000000000; tv&lt;=9'b111111111; tv = tv+1'b1) begin\n                en = tv[0];\n                #5;\n                in1 = tv[8:5];\n                in0 = tv[4:1];\n                assign out_exp = en? in1 : in0;\n                #5;\n                assert(out == out_exp) else begin\n                    $display(\"Error: inputs = %b\", tv);\n                    $display(\" outputs = %b(%b expected)\", out, in1);\n                    errors = errors + 1;\n                end\n                if (tv == 9'b111111111) begin\n                    vectornum = vectornum + 1;\n                    $display(\"%d tests completed with %d errors\", vectornum, errors);\n                    $stop;\n                end\n                else begin\n                    vectornum = vectornum + 1;\n                end\n            end\n            $display(\"%d tests completed with %d errors\", vectornum, errors);\n            $stop;\n        end\nendmodule\n/*\nTestbench for seven_segment_display.sv\n4-bit input, 7-bit output\n3 September 2025\nMadeleine Kan\nmkan@g.hmc.edu\n*/\nmodule seven_segment_display_testbench();\n    logic clk, reset;\n    logic [3:0] s;\n    logic [6:0] seg, seg_exp;\n    logic [31:0] vectornum, errors;\n    logic [10:0] testvectors[10000:0];\n    seven_segment_display dut(s, seg);\n    always\n        begin\n            clk=1; #5; \n            clk=0; #5;\n        end\n    initial\n        begin\n            $readmemb(\"C:/Users/mkan/Documents/GitHub/e155-lab2/lab2/source/impl_1/seg_exp.tv\", testvectors);\n            vectornum=0; \n            errors=0;\n            reset=1; #5; \n            reset=0;\n        end\n    always @(posedge clk)\n        begin\n            #1;\n            {s, seg_exp} = testvectors[vectornum];\n        end\n    always @(negedge clk)\n        if (~reset) begin\n            if (seg !== seg_exp) begin\n                $display(\"Error: inputs = %b\", seg);\n                $display(\" outputs = %b(%b expected)\", seg, seg_exp);\n                errors = errors + 1;\n            end\n            vectornum = vectornum + 1;\n            if (testvectors[vectornum] === 11'bx) begin\n                $display(\"%d tests completed with %d errors\", vectornum, errors);\n                $stop;\n            end\n        end\nendmodule"
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-reflection",
    "href": "labs/lab3/lab3.html#ai-reflection",
    "title": "Lab 3",
    "section": "AI Reflection",
    "text": "AI Reflection"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5",
    "section": "",
    "text": "The purpose of this lab was to print out the speed of a brushed DC motor, in revolutions per second, based on interrupt signals from a quadrature encoder. These results were compared with the timing of using polling instead of interrupts."
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "Lab 5",
    "section": "",
    "text": "The purpose of this lab was to print out the speed of a brushed DC motor, in revolutions per second, based on interrupt signals from a quadrature encoder. These results were compared with the timing of using polling instead of interrupts."
  },
  {
    "objectID": "labs/lab5/lab5.html#schematic",
    "href": "labs/lab5/lab5.html#schematic",
    "title": "Lab 5",
    "section": "Schematic",
    "text": "Schematic\nThe circuit diagram is as follows:\n\nA flow chart describing the flow of the program is as follows:"
  },
  {
    "objectID": "labs/lab5/lab5.html#calculations",
    "href": "labs/lab5/lab5.html#calculations",
    "title": "Lab 5",
    "section": "Calculations",
    "text": "Calculations\nMotor speed as a function of count (an integer which was incremented on every rising and falling edge of both quadrature encoders) was calcualted as follows:"
  },
  {
    "objectID": "labs/lab5/lab5.html#code",
    "href": "labs/lab5/lab5.html#code",
    "title": "Lab 5",
    "section": "Code:",
    "text": "Code:\nmain.c\n// main.c\n// reads quadrature encoder signals\n// prints speed of motor in rotations per second\n// Madeleine Kan\n// mkan@hmc.edu\n// 10/8/25\n\n#include \"main.h\"\n\nfloat count = 0;\nint A;\nint B;\n\n// Runs interrupt or polling version of main code\nint main(void) {\n    int interrupt = 1;\n    if (interrupt == 1){\n      motorInterrupt();\n    } else {\n      motorPoll();\n    }\n    return 0;\n\n}\n\n// Detects encoder pulses with interrupts\nvoid motorInterrupt(void){\n  // Enable quadrature encoder inputs\n    gpioEnable(GPIO_PORT_A);\n    pinMode(QUAD_ENCODER_A, GPIO_INPUT);\n    pinMode(QUAD_ENCODER_B, GPIO_INPUT);\n    GPIOA-&gt;PUPDR |= _VAL2FLD(GPIO_PUPDR_PUPD1, 0b01); // Set PA1 as pull-up\n    GPIOA-&gt;PUPDR |= _VAL2FLD(GPIO_PUPDR_PUPD2, 0b01); // Set PA2 as pull-up\n\n    // Enable PA7 as a flag for quadtrature encoder A\n    pinMode(INTERRUPT_A, GPIO_OUTPUT);\n    digitalWrite(INTERRUPT_A, 0);\n\n    // Initialize timer\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\n    initTIM(DELAY_TIM);\n\n    // 1. Enable SYSCFG clock domain in RCC\n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SYSCFGEN;\n    // 2. Configure EXTICR for the input quadrature encoder interrupts PA1 and PA2\n    SYSCFG-&gt;EXTICR[0] |= _VAL2FLD(SYSCFG_EXTICR1_EXTI1, 0b000);\n    SYSCFG-&gt;EXTICR[0] |= _VAL2FLD(SYSCFG_EXTICR1_EXTI2, 0b000);\n\n    // Enable interrupts globally\n    __enable_irq();\n\n    // Configure interrupt for rising and falling edge of GPIO pin for quadrature encoders\n    // 1. Configure mask bit\n    EXTI-&gt;IMR1 |= (1 &lt;&lt; gpioPinOffset(QUAD_ENCODER_A)); \n    EXTI-&gt;IMR1 |= (1 &lt;&lt; gpioPinOffset(QUAD_ENCODER_B));\n    // 2. Enable rising edge trigger\n    EXTI-&gt;RTSR1 |= (1 &lt;&lt; gpioPinOffset(QUAD_ENCODER_A));\n    EXTI-&gt;RTSR1 |= (1 &lt;&lt; gpioPinOffset(QUAD_ENCODER_B));\n    // 3. Enable falling edge trigger\n    EXTI-&gt;FTSR1 |= (1 &lt;&lt; gpioPinOffset(QUAD_ENCODER_A));\n    EXTI-&gt;FTSR1 |= (1 &lt;&lt; gpioPinOffset(QUAD_ENCODER_B));\n    // 4. Turn on EXTI interrupts in NVIC_ISER\n    NVIC-&gt;ISER[0] |= (1 &lt;&lt; EXTI1_IRQn);\n    NVIC-&gt;ISER[0] |= (1 &lt;&lt; EXTI2_IRQn);\n\n    while(1){   \n        delay_millis(TIM2, 500);\n        float speed = count / (4 * 0.5 * 408);\n        printf(\"motor speed: %f rev/s \\n\", speed);\n        count = 0;\n    }\n}\n\n// Quad encoder A interrupt handler\nvoid EXTI1_IRQHandler(void){\n    // Check that quad_encoder_a was what triggered our interrupt\n    A = digitalRead(gpioPinOffset(QUAD_ENCODER_A));\n    B = digitalRead(gpioPinOffset(QUAD_ENCODER_B));\n    if (EXTI-&gt;PR1 & (1 &lt;&lt; gpioPinOffset(QUAD_ENCODER_A))){\n        // If so, clear the interrupt (NB: Write 1 to reset.)\n        EXTI-&gt;PR1 |= (1 &lt;&lt; gpioPinOffset(QUAD_ENCODER_A));\n        if (A != B){ // B lags after A\n          count++;\n        } else { // A lags after B\n          count--;\n        }\n        togglePin(INTERRUPT_A);\n    }\n}\n\n// Quad encoder B interrupt handler\nvoid EXTI2_IRQHandler(void){\n    // Check that quad_encoder_b was what triggered our interrupt\n    A = digitalRead(gpioPinOffset(QUAD_ENCODER_A));\n    B = digitalRead(gpioPinOffset(QUAD_ENCODER_B));\n    if (EXTI-&gt;PR1 & (1 &lt;&lt; gpioPinOffset(QUAD_ENCODER_B))){\n        // If so, clear the interrupt (NB: Write 1 to reset.)\n        EXTI-&gt;PR1 |= (1 &lt;&lt; gpioPinOffset(QUAD_ENCODER_B)); \n        if (B == A){ // B lags after A\n          count++;\n        } else { // A lags after B\n          count--;\n        }\n        //togglePin(LED_PIN);\n\n    }\n}\n\n// Detects encoder pulses with polling\nvoid motorPoll(void){\n    // Polling\n    int volatile curA = digitalRead(QUAD_ENCODER_A);\n    int volatile curB = digitalRead(QUAD_ENCODER_B);\n    int volatile prevA = curA;\n    int volatile prevB = curB;\n    uint32_t ms = 500;\n    \n    // Enable quadrature encoder inputs\n    gpioEnable(GPIO_PORT_A);\n    pinMode(QUAD_ENCODER_A, GPIO_INPUT);\n    pinMode(QUAD_ENCODER_B, GPIO_INPUT);\n    GPIOA-&gt;PUPDR |= _VAL2FLD(GPIO_PUPDR_PUPD1, 0b01); // Set PA1 as pull-up\n    GPIOA-&gt;PUPDR |= _VAL2FLD(GPIO_PUPDR_PUPD2, 0b01); // Set PA2 as pull-up\n\n    // Enable PA7 as a flag for quadtrature encoder A\n    pinMode(INTERRUPT_A, GPIO_OUTPUT);\n    digitalWrite(INTERRUPT_A, 0);\n\n    // Initialize timer\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\n    initTIM(DELAY_TIM);\n\n    // 1. Enable SYSCFG clock domain in RCC\n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SYSCFGEN;\n    // 2. Configure EXTICR for the input quadrature encoder interrupts PA1 and PA2\n    SYSCFG-&gt;EXTICR[0] |= _VAL2FLD(SYSCFG_EXTICR1_EXTI1, 0b000);\n    SYSCFG-&gt;EXTICR[0] |= _VAL2FLD(SYSCFG_EXTICR1_EXTI2, 0b000);\n\n    // A lot of this code is adapted from delay_millis \n    // so that polling can be executed within the while loop\n    while(1){\n      DELAY_TIM-&gt;ARR = ms;// Set timer max count\n      DELAY_TIM-&gt;EGR |= 1;     // Force update\n      DELAY_TIM-&gt;SR &= ~(0x1); // Clear UIF\n      DELAY_TIM-&gt;CNT = 0;      // Reset count\n      while(!(DELAY_TIM-&gt;SR & 1)){ // Wait for UIF to go high\n        prevA = curA;\n        prevB = curB;\n        curA = digitalRead(QUAD_ENCODER_A);\n        curB = digitalRead(QUAD_ENCODER_B);\n        if (prevA != curA) { // A changes\n          if (curA != curB){ // B lag behind A\n            count++;\n          } else {\n            count--;\n          }\n          togglePin(INTERRUPT_A);\n        } else if (prevB != curB) { // B changes\n            if (curA == curB) { // B lag behind A\n              count++;\n            } else {\n              count --;\n            }\n        }\n      }\n      float speed = count / (4 * 0.5 * 408);\n      printf(\"motor speed: %f rev/s \\n\", speed);\n      count = 0;\n    }\n}\nAccompanying header file, main.h:\n// main.h\n// Madeleine Kan\n// mkan@hmc.edu\n// 10/8/25\n\n#ifndef MAIN_H\n#define MAIN_H\n\n#include \"STM32L432KC.h\"\n#include &lt;stm32l432xx.h&gt;\n\n#define LED_PIN PB3\n#define BUTTON_PIN PA4\n#define QUAD_ENCODER_A PA1\n#define INTERRUPT_A PA7\n#define QUAD_ENCODER_B PA2\n#define DELAY_TIM TIM2\n\n#endif // MAIN_H\n\nvoid motorInterrupt(void);\nvoid motorPoll(void);"
  },
  {
    "objectID": "labs/lab5/lab5.html#results",
    "href": "labs/lab5/lab5.html#results",
    "title": "Lab 5",
    "section": "Results",
    "text": "Results\nThe lab worked as expected! The MCU catches all signals at a high frequency, outputs a non-zero speed at low frequency, and a 0 speed when the motor is not powered. When the polarity of the power supplied to the motor is flipped, the sign of the output speed is also flipped. At ~10V, the script printed out a speed of 2.49 rev/sec.¬†I verified this speed by counting how many revolutions the motor made over a minute (using cookie clicker). I got 149 revolutions over 60 seconds, which corresponds to a speed of 2.48 rev/sec.\nThe oscilloscope trace below shows the signal from quadrature encoder A (in blue) and the corresponding interrupt signal (in yellow).\n\nAs shown in the distance between the vertical cursors, there is a delay between the encoder impulse and the interrupt signal of 260uS = 0.26 ms. Also, note that both signals have the same frequency of 1.01kHz. Based on this, I calculated the actual speed based on quad encoder A frequency. This resulted in an actual speed of 2.48 rev/sec, which is within 0.5% of the value of 2.49% calculated by the MCU.\n\nI then ran the script using polling, and obtained the following oscilloscope trace showing the same signal from quadrature encoder A (in blue) and the corresponding polled signal (in blue).\n\nAs can be seen from the cursors, the delay between the encoder impulse and the polled signal of 620 uS = 0.62 ms, which is more than double the interrupt delay. Also, note that the encoder impulse has a frequency of 1.01 kHz, while the polled signal has a frequency of 980 Hz. Compare this to the lack of frequency delay observed in interrupts. This ocurrs due to the fact that interrupts handle code in hardware ‚Äì when a trigger event happens, the MCU updates the program counter to point to the interrupt handler. This means, when the trigger event is not ocurring, the software experiences no delay from the interrupt handler. Any delays in interrupt handling are due to the length/intensity of the interrupt handler script. Polling, on the other hand, relies on software to repeatedly check for any trigger events. This inherently limits the frequency at which polling can occur. Investigating this further, I wrote a script that toggles a GPIO pin in a while loop with no trigger or hardcoded delay. This yielded a square wave captured in the following oscilloscope trace:\n\nThe maximum possible polling frequency is 20.8 kHz. From this, we can calculate the max speed that polling can accurately sample according to Nyquist‚Äôs sampling theorem."
  },
  {
    "objectID": "labs/lab5/lab5.html#summary",
    "href": "labs/lab5/lab5.html#summary",
    "title": "Lab 5",
    "section": "Summary",
    "text": "Summary\nI have spent ~10 hours on this lab. during this process, I learned a lot about interrupts, their advantage over polling, and quadrature encoders! It was really exciting to concretely compare the timing of the two methods. Additionally, I had fun developing a script to do something that felt tangible, and useful! Also, my classmates were super kind and helpful, which I really appreciated."
  },
  {
    "objectID": "labs/lab5/lab5.html#ai-reflection",
    "href": "labs/lab5/lab5.html#ai-reflection",
    "title": "Lab 5",
    "section": "AI Reflection",
    "text": "AI Reflection\nFor this week‚Äôs AI Refleciton, I asked ChatGPT to ‚ÄúWrite me interrupt handlers to interface with a quadrature encoder. I‚Äôm using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?‚Äù. Initially, the code it gave me had a few typos. To get the code to compile, I had to change APB1ENR to APB1ENR1 and RCC_APB1ENR_TIM2EN to RCC_APB1ENR1_TIM2EN. Once the code compiled, I added a print statement. However, nothing ended up printing. I think the timer was not fully configured (e.g.¬†some necessary reegisters were not enabled). Besides this, I think the code that chatGPT produced was not super organized. While it did a good job of demonstrating the core functionality of the code, it used very few helper functions, and it wasn‚Äôt super readable. For instance, there was some raw timer bit manipulation in the TIM2_IRQ function, which was hard to interpret. That being said, the comments were useful! Below is the copy of the code that ChatGPT produced that I then modified:\n#include \"main.h\"\n\nint main(void){\n  // Configure PA0 and PA1 as alternate function (AF mode) for Timer\n  GPIOA-&gt;MODER &= ~(GPIO_MODER_MODE0_Msk | GPIO_MODER_MODE1_Msk); // Clear PA0 and PA1 mode\n  GPIOA-&gt;MODER |= (GPIO_MODER_MODE0_1 | GPIO_MODER_MODE1_1); // Set PA0 and PA1 to alternate function\n  GPIOA-&gt;AFR[0] |= (0x2 &lt;&lt; GPIO_AFRL_AFSEL0_Pos); // Set AF2 for PA0 (TIM2_CH1)\n  GPIOA-&gt;AFR[0] |= (0x2 &lt;&lt; GPIO_AFRL_AFSEL1_Pos); // Set AF2 for PA1 (TIM2_CH2)\n\n  // Enable the TIM2 clock\n  RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\n\n  // Configure TIM2 in Encoder Mode\n  TIM2-&gt;PSC = 0;  // Prescaler (no division)\n  TIM2-&gt;ARR = 0xFFFF;  // Auto-reload register (max count)\n  TIM2-&gt;CR1 = TIM_CR1_CEN;  // Enable the timer\n\n  // Set the encoder mode (e.g., Encoder mode 1: Count rising edges of encoder signals)\n  TIM2-&gt;SMCR = (TIM_SMCR_SMS_0 | TIM_SMCR_SMS_1);  // Encoder Mode 1 (TI1 + TI2)\n\n  TIM2-&gt;DIER |= TIM_DIER_UIE;  // Enable update interrupt (overflow interrupt)\n\n  // Enable NVIC for TIM2 interrupt\n  NVIC_EnableIRQ(TIM2_IRQn);\n\n}\n\nvoid TIM2_IRQHandler(void) {\n    if (TIM2-&gt;SR & TIM_SR_UIF) {  // Check if interrupt was caused by update event (overflow)\n        TIM2-&gt;SR &= ~TIM_SR_UIF;  // Clear the interrupt flag\n        // Handle your encoder position change here\n        uint32_t encoder_position = TIM2-&gt;CNT;  // Read the counter value\n        // Example: Print or process the encoder position\n        printf(\"encoder position: %d\", encoder_position);\n    }\n}"
  },
  {
    "objectID": "labs/lab5/lab5.html#resources",
    "href": "labs/lab5/lab5.html#resources",
    "title": "Lab 5",
    "section": "Resources",
    "text": "Resources\nSource code"
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7",
    "section": "",
    "text": "Lab 7 uses the MCU and the FPGA together to perform encryption on a 128-bit long string according to AES-128. There, the FPGA serves an accelerator for the 10 rounds of encryption. Information is communicated between the MCU and the FPGA over SPI."
  },
  {
    "objectID": "labs/lab7/lab7.html#introduction",
    "href": "labs/lab7/lab7.html#introduction",
    "title": "Lab 7",
    "section": "",
    "text": "Lab 7 uses the MCU and the FPGA together to perform encryption on a 128-bit long string according to AES-128. There, the FPGA serves an accelerator for the 10 rounds of encryption. Information is communicated between the MCU and the FPGA over SPI."
  },
  {
    "objectID": "labs/lab7/lab7.html#block-diagrams",
    "href": "labs/lab7/lab7.html#block-diagrams",
    "title": "Lab 7",
    "section": "Block Diagrams",
    "text": "Block Diagrams\nThe block diagrams for the design are as follows:\ntop-level aes module (performs aes encrpytion and transmits results over spi)\n\naes core module (performs aes encrpytion using aes datapath, controller FSM, and counter FSM):\n\naes datapath (performs one round of aes encryption):\n\ncontroller fsm (controller for aes datapath):\n\ncounter fsm (counts rounds of encryption, up to 10 for AES-128):"
  },
  {
    "objectID": "labs/lab7/lab7.html#code",
    "href": "labs/lab7/lab7.html#code",
    "title": "Lab 7",
    "section": "Code:",
    "text": "Code:\n\n/////////////////////////////////////////////\n// aes\n//   Top level module with SPI interface and SPI core\n/////////////////////////////////////////////\n\nmodule aes(input  logic sck, \n           input  logic sdi,\n           output logic sdo,\n           input  logic load,\n           output logic done,\n           output logic led);\n    logic [127:0] key, plaintext, cyphertext;\n    // sck = pB3 = P21\n    // cipo = sdo = pb4 = p12\n    // copi = sdi = pb5 = p10\n    // load = pa5 = p26\n    // done = pa6 = p27\n    \n    logic clk;\n    \n    hsosc clock(clk);\n    aes_spi spi(sck, sdi, sdo, done, key, plaintext, cyphertext);   \n    aes_core core(clk, load, key, plaintext, done, cyphertext);\n    \n    logic [23:0] counter;\n    always_ff @(posedge clk)\n        counter &lt;= counter + 24'b1;\n    assign led = counter[23];\nendmodule\n\n/////////////////////////////////////////////\n// aes_core\n//   top level AES encryption module\n//   when load is asserted, takes the current key and plaintext\n//   generates cyphertext and asserts done when complete 11 cycles later\n// \n//   See FIPS-197 with Nk = 4, Nb = 4, Nr = 10\n//\n//   The key and message are 128-bit values packed into an array of 16 bytes as\n//   shown below\n//        [127:120] [95:88] [63:56] [31:24]     S0,0    S0,1    S0,2    S0,3\n//        [119:112] [87:80] [55:48] [23:16]     S1,0    S1,1    S1,2    S1,3\n//        [111:104] [79:72] [47:40] [15:8]      S2,0    S2,1    S2,2    S2,3\n//        [103:96]  [71:64] [39:32] [7:0]       S3,0    S3,1    S3,2    S3,3\n//\n//   Equivalently, the values are packed into four words as given\n//        [127:96]  [95:64] [63:32] [31:0]      w[0]    w[1]    w[2]    w[3]\n/////////////////////////////////////////////\n\nmodule aes_core(input  logic         clk, \n                input  logic         load,\n                input  logic [127:0] key_in, \n                input  logic [127:0] plaintext, \n                output logic         done,\n                output logic [127:0] cyphertext);\nlogic inc_roundnum, start, update, bypasscols;\nlogic [3:0] roundnum;\nlogic [127:0] state, key, newstate, newkey, oldstate, oldkey;\n\n\nalways_ff @(posedge clk) begin\n        if (start) begin\n            key &lt;= key_in;\n            state &lt;= (plaintext ^ key_in);\n        end else if (update) begin\n            key &lt;= newkey;\n            state &lt;= newstate;\n        end\n        else begin\n            key &lt;= key;\n            state &lt;= state; // will become an issue in later rounds\n        end\n    end\naes_controller_fsm controller(clk, load, roundnum, start, update, bypasscols, done, inc_roundnum);\naes_counter_fsm counter(clk, inc_roundnum, load, roundnum);\naes_datapath dp(clk, bypasscols, done, roundnum, state, key, newstate, newkey);\n\nassign cyphertext = done? newstate : 128'b0;\n            \nendmodule\n/////////////////////////////////////////////\n// aes_datapath\n//   \n//   See FIPS-197 with Nk = 4, Nb = 4, Nr = 10\n//\n//   The key and message are 128-bit values packed into an array of 16 bytes as\n//   shown below\n//        [127:120] [95:88] [63:56] [31:24]     S0,0    S0,1    S0,2    S0,3\n//        [119:112] [87:80] [55:48] [23:16]     S1,0    S1,1    S1,2    S1,3\n//        [111:104] [79:72] [47:40] [15:8]      S2,0    S2,1    S2,2    S2,3\n//        [103:96]  [71:64] [39:32] [7:0]       S3,0    S3,1    S3,2    S3,3\n//\n//   Equivalently, the values are packed into four words as given\n//        [127:96]  [95:64] [63:32] [31:0]      w[0]    w[1]    w[2]    w[3]\n/////////////////////////////////////////////\n\nmodule aes_datapath(input  logic clk, \n                input  logic bypassCols, done,\n                input logic [3:0] roundNum,\n                input  logic [127:0] state, \n                input  logic [127:0] key,\n                output logic [127:0] newstate,\n                output logic [127:0] newkey);\n    logic [127:0] state_subbytes, state_shiftrows, state_shiftedrows, state_mixcols, state_readyforkeys;\n    logic [31:0] w0, w1, w2, w3;\n\n    keyexpansion k(clk, key, roundNum, newkey);\n\n    // key is ready 2 rising edges after rising edge is loaded\n    assign {w0, w1, w2, w3} = newkey;\n    subbytes sb(state, clk, state_subbytes); // takes a clk cycle\n    shiftrows sr(state_subbytes, state_shiftrows);\n    always_ff @(posedge clk) begin\n        state_shiftedrows &lt;= state_shiftrows;\n    end\n    mixcolumns mc(state_shiftedrows, state_mixcols);\n    assign state_readyforkeys = bypassCols? state_shiftedrows : state_mixcols;\n    \n    //addkeys\n    assign newstate = state_readyforkeys ^ newkey;\n    \nendmodule\n// FSM for controller for AES datapath\nmodule aes_controller_fsm(input  logic clk, load,\n                          input logic [3:0] roundnum,\n                          output logic start, update, bypasscols, done, inc_roundnum);\n    typedef enum logic [3:0] {idle, ready, start_first, start_cont, shiftrows, subbytes, mixcols, dontmix, finish} statetype;\n    statetype state, nextstate;\n    // assign nextstate = idle;\n    \n    // state register\n    always_ff @(posedge clk)\n        state &lt;= nextstate;\n\n    \n    // state transition + output logic\n    always_comb\n        case(state)\n            idle: begin\n                start = 1'b0;\n                update = 1'b0;\n                inc_roundnum = 1'b0;\n                bypasscols = 1'b0;\n                done = 1'b0;\n                if (load) begin\n                    nextstate = ready;\n                end else begin \n                    nextstate = idle;\n                end\n            end\n            ready: begin\n                start = 1'b0;\n                update = 1'b0;\n                inc_roundnum = 1'b0;\n                bypasscols = 1'b0;\n                done = 1'b0;\n                if (!load) begin\n                    nextstate = start_first;\n                end else begin \n                    nextstate = ready;\n                end\n            end\n            start_first: begin\n                start = 1'b1;\n                update = 1'b0;\n                inc_roundnum = 1'b1;\n                bypasscols = 1'b0;\n                done = 1'b0;\n                nextstate = subbytes;\n            end\n            start_cont: begin\n                start = 1'b0;\n                update = 1'b1;      \n                inc_roundnum = 1'b1;\n                bypasscols = 1'b0;\n                done = 1'b0;\n                nextstate = subbytes;\n            end\n            subbytes: begin\n                start = 1'b0;\n                update = 1'b0;\n                inc_roundnum = 1'b0;\n                bypasscols = 1'b0;\n                done = 1'b0;\n            nextstate = shiftrows;\n            end\n            shiftrows: begin\n                start = 1'b0;\n                update = 1'b0;\n                inc_roundnum = 1'b0;\n                bypasscols = 1'b0;\n                done = 1'b0;\n                if (roundnum &gt;= 4'd10) begin\n                    nextstate = dontmix;\n                end else begin\n                    nextstate = mixcols;\n                end\n            end\n            mixcols: begin\n                start = 1'b0;\n                update = 1'b0;\n                inc_roundnum = 1'b0;\n                bypasscols = 1'b0;\n                done = 1'b0;\n                nextstate = start_cont;\n            end\n            dontmix: begin\n                start = 1'b0;\n                update = 1'b0;\n                inc_roundnum = 1'b0;\n                bypasscols = 1'b1;\n                done = 1'b0;\n                nextstate = finish;\n            end \n            finish: begin\n                start = 1'b0;\n                update = 1'b0;\n                inc_roundnum = 1'b0;\n                bypasscols = 1'b1;\n                done = 1'b1;\n                nextstate = finish;\n            end\n            default: begin\n                start = 1'b0;\n                update = 1'b0;\n                inc_roundnum = 1'b0;\n                bypasscols = 1'b0;\n                done = 1'b0;\n                nextstate = idle;\n                // try staying at finish\n            end\n        endcase\n        \nendmodule\n// FSM to count how many rounds of cipher algorithm\n// have been executed in AES\nmodule aes_counter_fsm(input  logic clk, inc_roundnum, load,\n                        output logic [3:0] roundnum);\n    typedef enum logic [3:0] {s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10} statetype;\n    statetype state, nextstate;\n    // state register\n    always_ff @(posedge clk)\n        if (load) state &lt;= s0;\n        else state &lt;= nextstate;\n\n\n    // state transition + output logic\n    always_comb\n        case(state)\n            s0: begin\n                if (inc_roundnum) nextstate = s1;\n                else nextstate = s0;\n                roundnum = 4'd0;\n            end\n            s1: begin\n                if (inc_roundnum) nextstate = s2;\n                else nextstate = s1;\n                roundnum = 4'd1;\n            end\n            s2: begin\n                if (inc_roundnum) nextstate = s3;\n                else nextstate = s2;\n                roundnum = 4'd2;\n            end\n            s3: begin\n                if (inc_roundnum) nextstate = s4;\n                else nextstate = s3;\n                roundnum = 4'd3;\n            end\n            s4: begin\n                if (inc_roundnum) nextstate = s5;\n                else nextstate = s4;\n                roundnum = 4'd4;\n            end\n            s5: begin\n                if (inc_roundnum) nextstate = s6;\n                else nextstate = s5;\n                roundnum = 4'd5;\n            end\n            s6: begin\n                if (inc_roundnum) nextstate = s7;\n                else nextstate = s6;\n                roundnum = 4'd6;\n            end\n            s7: begin\n                if (inc_roundnum) nextstate = s8;\n                else nextstate = s7;\n                roundnum = 4'd7;\n            end\n            s8: begin\n                if (inc_roundnum) nextstate = s9;\n                else nextstate = s8;\n                roundnum = 4'd8;\n            end\n            s9: begin\n                if (inc_roundnum) nextstate = s10;\n                else nextstate = s9;\n                roundnum = 4'd9;\n            end\n            s10: begin\n                // if (done) nextstate = s0;\n                // else \n                nextstate = s10;\n                roundnum = 4'd10;\n            end\n            default: begin\n                nextstate = s0;\n                roundnum = 4'd0;\n            end\n        endcase\nendmodule\n/////////////////////////////////////////////\n// subbytes\n//   apply sbox_sync to all elements of input\n/////////////////////////////////////////////\n\nmodule subbytes(input  logic [127:0] a,\n                input logic clk,\n                output logic [127:0] y);\n    sbox_sync sb[15:0] (a, clk, y);\n\nendmodule\n/////////////////////////////////////////////\n// shiftrows\n//   Perform shiftrow on all 4 rows of the input\n//   Section 5.1.2, Figure 3\n/////////////////////////////////////////////\n\nmodule shiftrows(input  logic [127:0] a, output logic [127:0] y);\n// each row is 4 bytes or 32 bits long\n    logic [31:0] row0in, row1in, row2in, row3in;\n    logic [31:0] row0out, row1out, row2out, row3out;\n\n    assign row0in = {a[127:120], a[95:88], a[63:56], a[31:24]};\n    assign row1in = {a[119:112], a[87:80], a[55:48], a[23:16]};\n    assign row2in = {a[111:104], a[79:72], a[47:40], a[15:8]};\n    assign row3in = {a[103:96], a[71:64], a[39:32], a[7:0]};\n\n    shiftrow sr0(row0in, 2'b00, row0out);\n    shiftrow sr1(row1in, 2'b01, row1out);\n    shiftrow sr2(row2in, 2'b10, row2out);\n    shiftrow sr3(row3in, 2'b11, row3out);\n\n    assign {y[127:120], y[95:88], y[63:56], y[31:24]} = row0out;\n    assign {y[119:112], y[87:80], y[55:48], y[23:16]} = row1out;\n    assign {y[111:104], y[79:72], y[47:40], y[15:8]} = row2out;\n    assign {y[103:96], y[71:64], y[39:32], y[7:0]} = row3out;\n    \nendmodule"
  },
  {
    "objectID": "labs/lab7/lab7.html#results",
    "href": "labs/lab7/lab7.html#results",
    "title": "Lab 7",
    "section": "Results",
    "text": "Results\nThe lab worked as expected! Below are testbenches and their associated waveforms.\nCore testbench, zoomed out:\n\nCore testbench, zoomed in:\n\nalternate core test case, zoomed out:\n\nalternate core test case, zoomed in:\n\ndatapath round 1, zoomed in\n\ndatapath round 10, zoomed in\n\nspi, zoomed in\n\nspi, zoomed out\n\nkeyexpansion, zoomed out\n\nkeyexpansion, zoomed in\n\nshiftrows\n\nsubbytes"
  },
  {
    "objectID": "labs/lab7/lab7.html#summary",
    "href": "labs/lab7/lab7.html#summary",
    "title": "Lab 7",
    "section": "Summary",
    "text": "Summary\nI probably spent ~30 hours on this lab!"
  },
  {
    "objectID": "labs/lab7/lab7.html#ai-reflection",
    "href": "labs/lab7/lab7.html#ai-reflection",
    "title": "Lab 7",
    "section": "AI Reflection",
    "text": "AI Reflection\nWith context:\nFor the AI reflection, I prompted chatgpt to essentially impelment part of the key expansion module, given otherwise defined rotword and subword modules. For one prompt, I uploaded the FIPS 197 AES specifications pdf, and I asked ChatGPT to implement key expansion based on it. For another, I provided ChatGPT with the keyexpansion pseudocode, but all submodules were abstracted and I specifically asked ChatGPT not to use existing knowledge of AES specifications. The interactions are linked below:\nhttps://chatgpt.com/share/6914f4ea-0a20-8006-b30a-0c86622abffa compiles! just doesn‚Äôt know what subword module is (since it isn‚Äôt defined lol) function automatic logic new\nWithout context: https://chatgpt.com/share/6914f69c-2e14-8006-892a-a21d3f702864 same as above\nThe first implementation of AES encryption key word generation that ChatGPT generated (With the AES specification as context) was quite good! When I added it to Radiant and specified it as the top-level module, it mostly compiled (aside from the rotword and subbytes modules not being recognized, as expected). One thing to note is that ChatGPT did assume subword to be combinational, which was not the case in my implementation due to the limits of FPGA memory. However, the response came with comments (both in and out of the code) that made this assumption clear. I‚Äôm sure this could have been remedied by specifying the architecture that the algorithm is being written for, outlining memory capacity concerns, or including my implementation of subword for reference. The code that ChatGPT generated also used a ‚Äúfunction automatic logic‚Äù, which is new to me! The script also outlined a proposed implementation for the RotWord and SubWord modules, as well as an example function call using the keyWordGen module.\nThe second implementation of the AES encryption key word generation function was generated without prior knowledge of the AES encryption standard. Similar to above, once I specified the top level module, it compiled as expected, with the exception of missing the undefined module1 and module2. It also used genvar, which was new to me, but I had heard of it in passing for this class (unlike function automatic logic). Additionally, ChatGPT provided a helpful explanation on the genvar. While the in-line comments were useful, the lack of AES encryption context did hinder the readability/comprehensability of the code. However, it seems like the AI still did a good job implementing the pseudocode in SystemVerilog."
  },
  {
    "objectID": "posts/initial-reflection.html",
    "href": "posts/initial-reflection.html",
    "title": "Initial Reflection",
    "section": "",
    "text": "Firstly, I am hopen to work on developing my FPGA and MCU programming skills. Additionally, I want to work on my technical documentation and communication skills. I also want to work on project design, execution, and evaluation! Overall, I am excited to build a project that I find interesting and learn a lot of useful skills along the way."
  }
]